{
  "pxt.json": "{\n    \"name\": \"robotbit\",\n    \"version\": \"0.2.4\",\n    \"description\": \"Extension for Kittenbot Robotbit\",\n    \"license\": \"MIT\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"neopixel\": \"github:microsoft/pxt-neopixel#v0.6.2\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"main.ts\",\n        \"_locales/zh/robotbit-strings.json\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true\n}",
  "README.md": "# robotbit\n\nExtension for Kittenbot Robotbit\n\n## Feature\n\n- Designed for robotic projects over microbit\n- On board battery source\n- Drive 8x servos and 4x DC motors and the same time (with 3.7v battery source to VM)\n- Drive 2x Micro Stepper Motors\n- On board buzzer\n- On board 4x RGB Neo Pixels\n\n# Blocks Preview\n![image](https://user-images.githubusercontent.com/3390845/34512193-b3e0ffdc-f09b-11e7-839f-0c9c3563ac94.png)\n\n# Hardware Preview\n## Front\n![image](https://user-images.githubusercontent.com/3390845/34511999-4b3fdef4-f09a-11e7-960e-5661268b0ba7.png)\n\n## Back\n![image](https://user-images.githubusercontent.com/3390845/34512098-04fecc1a-f09b-11e7-9ec6-62fcc0780773.png)\n\n\n----------\n\nFor more infomation please visit [http://kittenbot.cc/bbs/](http://kittenbot.cc/bbs/ \"Kittenbot BBS\")\n\n## License\n\nMIT\n\n## Supported targets\n\n* for PXT/microbit\n(The metadata above is needed for package search.)\n\n```package\nrobotbit=github:Kittenbot/pxt-robotbit\n```",
  "main.ts": "/*\r\nRiven\r\nmodified from pxt-servo/servodriver.ts\r\nload dependency\r\n\"robotbit\": \"file:../pxt-robotbit\"\r\n*/\r\n\r\n\r\n//% color=\"#31C7D5\" weight=10 icon=\"\\uf1d0\"\r\nnamespace robotbit {\r\n    const PCA9685_ADDRESS = 0x40\r\n    const MODE1 = 0x00\r\n    const MODE2 = 0x01\r\n    const SUBADR1 = 0x02\r\n    const SUBADR2 = 0x03\r\n    const SUBADR3 = 0x04\r\n    const PRESCALE = 0xFE\r\n    const LED0_ON_L = 0x06\r\n    const LED0_ON_H = 0x07\r\n    const LED0_OFF_L = 0x08\r\n    const LED0_OFF_H = 0x09\r\n    const ALL_LED_ON_L = 0xFA\r\n    const ALL_LED_ON_H = 0xFB\r\n    const ALL_LED_OFF_L = 0xFC\r\n    const ALL_LED_OFF_H = 0xFD\r\n\r\n    const STP_CHA_L = 2047\r\n    const STP_CHA_H = 4095\r\n\r\n    const STP_CHB_L = 1\r\n    const STP_CHB_H = 2047\r\n\r\n    const STP_CHC_L = 1023\r\n    const STP_CHC_H = 3071\r\n\r\n    const STP_CHD_L = 3071\r\n    const STP_CHD_H = 1023\r\n\r\n    // HT16K33 commands\r\n    const HT16K33_ADDRESS = 0x70\r\n    const HT16K33_BLINK_CMD = 0x80\r\n    const HT16K33_BLINK_DISPLAYON = 0x01\r\n    const HT16K33_BLINK_OFF = 0\r\n    const HT16K33_BLINK_2HZ = 1\r\n    const HT16K33_BLINK_1HZ = 2\r\n    const HT16K33_BLINK_HALFHZ = 3\r\n    const HT16K33_CMD_BRIGHTNESS = 0xE0\r\n\r\n    export enum Servos {\r\n        S1 = 0x01,\r\n        S2 = 0x02,\r\n        S3 = 0x03,\r\n        S4 = 0x04,\r\n        S5 = 0x05,\r\n        S6 = 0x06,\r\n        S7 = 0x07,\r\n        S8 = 0x08\r\n    }\r\n\r\n    export enum Motors {\r\n        M1A = 0x1,\r\n        M1B = 0x2,\r\n        M2A = 0x3,\r\n        M2B = 0x4\r\n    }\r\n\r\n    export enum Steppers {\r\n        M1 = 0x1,\r\n        M2 = 0x2\r\n    }\r\n\r\n    export enum Turns {\r\n        //% blockId=\"T1B4\" block=\"1/4\"\r\n        T1B4 = 90,\r\n        //% blockId=\"T1B2\" block=\"1/2\"\r\n        T1B2 = 180,\r\n        //% blockId=\"T1B0\" block=\"1\"\r\n        T1B0 = 360,\r\n        //% blockId=\"T2B0\" block=\"2\"\r\n        T2B0 = 720,\r\n        //% blockId=\"T3B0\" block=\"3\"\r\n        T3B0 = 1080,\r\n        //% blockId=\"T4B0\" block=\"4\"\r\n        T4B0 = 1440,\r\n        //% blockId=\"T5B0\" block=\"5\"\r\n        T5B0 = 1800\r\n    }\r\n\r\n    let initialized = false\r\n    let initializedMatrix = false\r\n    let neoStrip: neopixel.Strip;\r\n    let matBuf = pins.createBuffer(17);\r\n    let distanceBuf = 0;\r\n\r\n    function i2cwrite(addr: number, reg: number, value: number) {\r\n        let buf = pins.createBuffer(2)\r\n        buf[0] = reg\r\n        buf[1] = value\r\n        pins.i2cWriteBuffer(addr, buf)\r\n    }\r\n\r\n    function i2ccmd(addr: number, value: number) {\r\n        let buf = pins.createBuffer(1)\r\n        buf[0] = value\r\n        pins.i2cWriteBuffer(addr, buf)\r\n    }\r\n\r\n    function i2cread(addr: number, reg: number) {\r\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\r\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\r\n        return val;\r\n    }\r\n\r\n    function initPCA9685(): void {\r\n        i2cwrite(PCA9685_ADDRESS, MODE1, 0x00)\r\n        setFreq(50);\r\n        for (let idx = 0; idx < 16; idx++) {\r\n            setPwm(idx, 0 ,0);\r\n        }\r\n        initialized = true\r\n    }\r\n\r\n    function setFreq(freq: number): void {\r\n        // Constrain the frequency\r\n        let prescaleval = 25000000;\r\n        prescaleval /= 4096;\r\n        prescaleval /= freq;\r\n        prescaleval -= 1;\r\n        let prescale = prescaleval; //Math.Floor(prescaleval + 0.5);\r\n        let oldmode = i2cread(PCA9685_ADDRESS, MODE1);\r\n        let newmode = (oldmode & 0x7F) | 0x10; // sleep\r\n        i2cwrite(PCA9685_ADDRESS, MODE1, newmode); // go to sleep\r\n        i2cwrite(PCA9685_ADDRESS, PRESCALE, prescale); // set the prescaler\r\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode);\r\n        control.waitMicros(5000);\r\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode | 0xa1);\r\n    }\r\n\r\n    function setPwm(channel: number, on: number, off: number): void {\r\n        if (channel < 0 || channel > 15)\r\n            return;\r\n\r\n        let buf = pins.createBuffer(5);\r\n        buf[0] = LED0_ON_L + 4 * channel;\r\n        buf[1] = on & 0xff;\r\n        buf[2] = (on >> 8) & 0xff;\r\n        buf[3] = off & 0xff;\r\n        buf[4] = (off >> 8) & 0xff;\r\n        pins.i2cWriteBuffer(PCA9685_ADDRESS, buf);\r\n    }\r\n\r\n\r\n    function setStepper(index: number, dir: boolean): void {\r\n        if (index == 1) {\r\n            if (dir) {\r\n                setPwm(0, STP_CHA_L, STP_CHA_H);\r\n                setPwm(2, STP_CHB_L, STP_CHB_H);\r\n                setPwm(1, STP_CHC_L, STP_CHC_H);\r\n                setPwm(3, STP_CHD_L, STP_CHD_H);\r\n            } else {\r\n                setPwm(3, STP_CHA_L, STP_CHA_H);\r\n                setPwm(1, STP_CHB_L, STP_CHB_H);\r\n                setPwm(2, STP_CHC_L, STP_CHC_H);\r\n                setPwm(0, STP_CHD_L, STP_CHD_H);\r\n            }\r\n        } else {\r\n            if (dir) {\r\n                setPwm(4, STP_CHA_L, STP_CHA_H);\r\n                setPwm(6, STP_CHB_L, STP_CHB_H);\r\n                setPwm(5, STP_CHC_L, STP_CHC_H);\r\n                setPwm(7, STP_CHD_L, STP_CHD_H);\r\n            } else {\r\n                setPwm(7, STP_CHA_L, STP_CHA_H);\r\n                setPwm(5, STP_CHB_L, STP_CHB_H);\r\n                setPwm(6, STP_CHC_L, STP_CHC_H);\r\n                setPwm(4, STP_CHD_L, STP_CHD_H);\r\n            }\r\n        }\r\n    }\r\n\r\n    function stopMotor(index: number) {\r\n        setPwm((index - 1) * 2, 0, 0);\r\n        setPwm((index - 1) * 2 + 1, 0, 0);\r\n    }\r\n\r\n    function matrixInit() {\r\n        i2ccmd(HT16K33_ADDRESS, 0x21);// turn on oscillator\r\n        i2ccmd(HT16K33_ADDRESS, HT16K33_BLINK_CMD | HT16K33_BLINK_DISPLAYON | (0 << 1));\r\n        i2ccmd(HT16K33_ADDRESS, HT16K33_CMD_BRIGHTNESS | 0xF);\r\n    }\r\n\r\n    function matrixShow() {\r\n        matBuf[0] = 0x00;\r\n        pins.i2cWriteBuffer(HT16K33_ADDRESS, matBuf);\r\n    }\r\n\r\n\r\n    /**\r\n     * Init RGB pixels mounted on robotbit\r\n     */\r\n    //% blockId=\"robotbit_rgb\" block=\"RGB\"\r\n    //% weight=5\r\n    export function rgb(): neopixel.Strip {\r\n        if (!neoStrip) {\r\n            neoStrip = neopixel.create(DigitalPin.P16, 4, NeoPixelMode.RGB)\r\n        }\r\n\r\n        return neoStrip;\r\n    }\r\n\r\n    /**\r\n     * Servo Execute\r\n     * @param index Servo Channel; eg: S1\r\n     * @param degree [0-180] degree of servo; eg: 0, 90, 180\r\n    */\r\n    //% blockId=robotbit_servo block=\"Servo|%index|degree %degree\"\r\n    //% weight=100\r\n    //% degree.min=0 degree.max=180\r\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\r\n    export function Servo(index: Servos, degree: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        // 50hz: 20,000 us\r\n        let v_us = (degree * 1800 / 180 + 600) // 0.6 ~ 2.4\r\n        let value = v_us * 4096 / 20000\r\n        setPwm(index + 7, 0, value)\r\n    }\r\n\r\n    /**\r\n     * Geek Servo\r\n     * @param index Servo Channel; eg: S1\r\n     * @param degree [-45-225] degree of servo; eg: -45, 90, 225\r\n    */\r\n    //% blockId=robotbit_gservo block=\"Geek Servo|%index|degree %degree\"\r\n    //% weight=99\r\n    //% blockGap=50\r\n    //% degree.min=-45 degree.max=225\r\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\r\n    export function GeekServo(index: Servos, degree: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        // 50hz: 20,000 us\r\n        let v_us = ((degree -90) * 20 / 3 + 1500) // 0.6 ~ 2.4\r\n        let value = v_us * 4096 / 20000\r\n        setPwm(index + 7, 0, value)\r\n    }\r\n    \r\n    //% blockId=robotbit_stepper_degree block=\"Stepper 28BYJ-48|%index|degree %degree\"\r\n    //% weight=90\r\n    export function StepperDegree(index: Steppers, degree: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        setStepper(index, degree > 0);\r\n        degree = Math.abs(degree);\r\n        basic.pause(10240 * degree / 360);\r\n        MotorStopAll()\r\n    }\r\n\r\n\r\n    //% blockId=robotbit_stepper_turn block=\"Stepper 28BYJ-48|%index|turn %turn\"\r\n    //% weight=90\r\n    export function StepperTurn(index: Steppers, turn: Turns): void {\r\n        let degree = turn;\r\n        StepperDegree(index, degree);\r\n    }\r\n\r\n    //% blockId=robotbit_stepper_dual block=\"Dual Stepper(Degree) |M1 %degree1| M2 %degree2\"\r\n    //% weight=89\r\n    export function StepperDual(degree1: number, degree2: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        setStepper(1, degree1 > 0);\r\n        setStepper(2, degree2 > 0);\r\n        degree1 = Math.abs(degree1);\r\n        degree2 = Math.abs(degree2);\r\n        basic.pause(10240 * Math.min(degree1, degree2) / 360);\r\n        if (degree1 > degree2) {\r\n            stopMotor(3); stopMotor(4);\r\n            basic.pause(10240 * (degree1 - degree2) / 360);\r\n        } else {\r\n            stopMotor(1); stopMotor(2);\r\n            basic.pause(10240 * (degree2 - degree1) / 360);\r\n        }\r\n\r\n        MotorStopAll()\r\n    }\r\n\r\n    /**\r\n     * Stepper Car move forward\r\n     * @param distance Distance to move in cm; eg: 10, 20\r\n     * @param diameter diameter of wheel in mm; eg: 48\r\n    */\r\n    //% blockId=robotbit_stpcar_move block=\"Car Forward|Diameter(cm) %distance|Wheel Diameter(mm) %diameter\"\r\n    //% weight=88\r\n    export function StpCarMove(distance: number, diameter: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        let delay = 10240 * 10 * distance / 3 / diameter; // use 3 instead of pi\r\n        setStepper(1, delay > 0);\r\n        setStepper(2, delay > 0);\r\n        delay = Math.abs(delay);\r\n        basic.pause(delay);\r\n        MotorStopAll()\t\r\n    }\r\n\r\n    /**\r\n     * Stepper Car turn by degree\r\n     * @param turn Degree to turn; eg: 90, 180, 360\r\n     * @param diameter diameter of wheel in mm; eg: 48\r\n     * @param track track width of car; eg: 125\r\n    */\r\n    //% blockId=robotbit_stpcar_turn block=\"Car Turn|Degree %turn|Wheel Diameter(mm) %diameter|Track(mm) %track\"\r\n    //% weight=87\r\n    //% blockGap=50\r\n    export function StpCarTurn(turn: number, diameter: number, track: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        let delay = 10240 * turn * track / 360 / diameter;\r\n        setStepper(1, delay < 0);\r\n        setStepper(2, delay > 0);\r\n        delay = Math.abs(delay);\r\n        basic.pause(delay);\r\n        MotorStopAll()\r\n    }\r\n\r\n    //% blockId=robotbit_motor_run block=\"Motor|%index|speed %speed\"\r\n    //% weight=85\r\n    //% speed.min=-255 speed.max=255\r\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\r\n    export function MotorRun(index: Motors, speed: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        speed = speed * 16; // map 255 to 4096\r\n        if (speed >= 4096) {\r\n            speed = 4095\r\n        }\r\n        if (speed <= -4096) {\r\n            speed = -4095\r\n        }\r\n        if (index > 4 || index <= 0)\r\n            return\r\n        let pp = (index - 1) * 2\r\n        let pn = (index - 1) * 2 + 1\r\n        if (speed >= 0) {\r\n            setPwm(pp, 0, speed)\r\n            setPwm(pn, 0, 0)\r\n        } else {\r\n            setPwm(pp, 0, 0)\r\n            setPwm(pn, 0, -speed)\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Execute two motors at the same time\r\n     * @param motor1 First Motor; eg: M1A, M1B\r\n     * @param speed1 [-255-255] speed of motor; eg: 150, -150\r\n     * @param motor2 Second Motor; eg: M2A, M2B\r\n     * @param speed2 [-255-255] speed of motor; eg: 150, -150\r\n    */\r\n    //% blockId=robotbit_motor_dual block=\"Motor|%motor1|speed %speed1|%motor2|speed %speed2\"\r\n    //% weight=84\r\n    //% speed1.min=-255 speed1.max=255\r\n    //% speed2.min=-255 speed2.max=255\r\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\r\n    export function MotorRunDual(motor1: Motors, speed1: number, motor2: Motors, speed2: number): void {\r\n        MotorRun(motor1, speed1);\r\n        MotorRun(motor2, speed2);\r\n    }\r\n\r\n    /**\r\n     * Execute single motors with delay\r\n     * @param index Motor Index; eg: M1A, M1B, M2A, M2B\r\n     * @param speed [-255-255] speed of motor; eg: 150, -150\r\n     * @param delay seconde delay to stop; eg: 1\r\n    */\r\n    //% blockId=robotbit_motor_rundelay block=\"Motor|%index|speed %speed|delay %delay|s\"\r\n    //% weight=81\r\n    //% speed.min=-255 speed.max=255\r\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\r\n    export function MotorRunDelay(index: Motors, speed: number, delay: number): void {\r\n        MotorRun(index, speed);\r\n        basic.pause(delay * 1000);\r\n        MotorRun(index, 0);\r\n    }\r\n\r\n\r\n\r\n    //% blockId=robotbit_stop block=\"Motor Stop|%index|\"\r\n    //% weight=80\r\n    export function MotorStop(index: Motors): void {\r\n        MotorRun(index, 0);\r\n    }\r\n\r\n    //% blockId=robotbit_stop_all block=\"Motor Stop All\"\r\n    //% weight=79\r\n    //% blockGap=50\r\n    export function MotorStopAll(): void {\r\n        for (let idx = 1; idx <= 4; idx++) {\r\n            stopMotor(idx);\r\n        }\r\n    }\r\n\r\n    //% blockId=robotbit_matrix_draw block=\"Matrix Draw|X %x|Y %y\"\r\n    //% weight=69\r\n    export function MatrixDraw(x: number, y: number): void {\r\n        if (!initializedMatrix) {\r\n            matrixInit();\r\n            initializedMatrix = true;\r\n        }\r\n        let idx = y * 2 + x / 8;\r\n        matBuf[idx + 1] |= (1 << (x % 8));\r\n        matrixShow();\r\n    }\r\n\r\n\t/*\r\n    //% blockId=robotbit_matrix_clean block=\"Matrix Clean|X %x|Y %y\"\r\n    //% weight=68\r\n    export function MatrixClean(x: number, y: number): void {\r\n        if (!initializedMatrix) {\r\n            matrixInit();\r\n            initializedMatrix = true;\r\n        }\r\n        let idx = y * 2 + x / 8;\r\n\t\t// todo: bitwise not throw err \r\n        matBuf[idx + 1] &=~(1 << (x % 8));\r\n        matrixShow();\r\n    }\r\n\t*/\r\n\r\n    //% blockId=robotbit_matrix_clear block=\"Matrix Clear\"\r\n    //% weight=65\r\n    //% blockGap=50\r\n    export function MatrixClear(): void {\r\n        if (!initializedMatrix) {\r\n            matrixInit();\r\n            initializedMatrix = true;\r\n        }\r\n        for (let i = 0; i < 16; i++) {\r\n            matBuf[i + 1] = 0;\r\n        }\r\n        matrixShow();\r\n    }\r\n\r\n    //% blockId=robotbit_ultrasonic block=\"Ultrasonic|pin %pin\"\r\n    //% weight=10\r\n    export function Ultrasonic(pin: DigitalPin): number {\r\n\r\n        // send pulse\r\n        pins.setPull(pin, PinPullMode.PullNone);\r\n        pins.digitalWritePin(pin, 0);\r\n        control.waitMicros(2);\r\n        pins.digitalWritePin(pin, 1);\r\n        control.waitMicros(10);\r\n        pins.digitalWritePin(pin, 0);\r\n\r\n        // read pulse\r\n        let d = pins.pulseIn(pin, PulseValue.High, 25000);\r\n        let ret = d;\r\n        // filter timeout spikes\r\n        if (ret == 0 && distanceBuf!= 0){\r\n            ret = distanceBuf;\r\n        }\r\n        distanceBuf = d;\r\n        return ret*10/6/58;\r\n    }\r\n\r\n\r\n}\r\n",
  "_locales/zh/robotbit-strings.json": "{\n\t\"robotbit.Servo|block\": \"舵机|%index|角度 %degree\",\n\t\"robotbit.StepperDegree|block\": \"步进 28BYJ-48|%index|角度 %degree\",\n\t\"robotbit.StepperTurn|block\": \"步进 28BYJ-48|%index|圈数 %turn\",\n\t\"robotbit.StepperDual|block\": \"双步进(角度) |M1 %degree1| M2 %degree2\",\n\t\"robotbit.StpCarMove|block\": \"步进小车 前进 |距离(cm) %distance|轮直径(mm) %diameter\",\n\t\"robotbit.StpCarTurn|block\": \"步进小车 转向 |角度 %turn|轮直径(mm) %diameter|轮距(mm) %track\",\n\t\"robotbit.MotorRun|block\": \"电机|%index|速度 %speed\",\n\t\"robotbit.MotorRunDual|block\": \"电机|%motor1|速度 %speed1|%motor2|速度 %speed2\",\n\t\"robotbit.MotorRunDelay|block\": \"电机|%index|速度 %speed|延时 %delay|s\",\n\t\"robotbit.MotorStop|block\": \"电机 停止|%index|\",\n\t\"robotbit.MotorStopAll|block\": \"停止所有电机\",\n\t\"robotbit.Ultrasonic|block\": \"超声波|引脚 %pin\",\n\t\"robotbit.MatrixDraw|block\": \"LED矩阵 描点|X %x|Y %y\",\n\t\"robotbit.MatrixClear|block\": \"LED矩阵 清空\"\n}",
  "test.ts": "// tests go here; this will not be compiled when this package is used as a library\n"
}