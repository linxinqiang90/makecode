{
  "pxt.json": "{\n    \"name\": \"neomatrix\",\n    \"version\": \"0.1.0\",\n    \"description\": \"NeoMatrix Display\",\n    \"license\": \"MIT\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"ws2812b\": \"github:Microsoft/pxt-ws2812b#v0.0.4\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"main.ts\"\n    ],\n    \"public\": true,\n    \"extension\": {\n        \"namespace\": \"neomatrix\",\n        \"label\": \"NeoMatrix Editor\",\n        \"localUrl\": \"http://kittenbot.cn/#/paint\"\n    }\n}",
  "README.md": "# Neo Matrix for makecode\r\n\r\nAn easy way to show anmations or images on neopixel matrix panel.\r\n\r\n![](./images/title.png)\r\n\r\n## How to use\r\n\r\n### NOTE: Makecode official don't support extension addons right now, you may need Makecode offline V3.2 or upper bundled by Kittenbot Team. \r\n\r\nLoad this extension to makecode editor and select **NeoMatrix Editor**, it will navigate to our website paint editor.  \r\n\r\n![](./images/editpanel.png)\r\n\r\nAfter finished editing the animation frames, please press **pxt-neomatrix** in the bottom left. You may find a newly added block **show frame** in makecode.\r\n\r\n![](./images/makecode.png)\r\n\r\nCheck the final effect\r\n\r\n![](./images/run.gif)\r\n\r\n----------\r\n\r\n## License\r\n\r\nMIT\r\n\r\n## Supported targets\r\n\r\n* for PXT/microbit\r\n(The metadata above is needed for package search.)\r\n\r\n```package\r\nneomatrix=github:Kittenbot/pxt-neomatrix\r\n```",
  "main.ts": "/*\r\nRiven\r\nNeoPixel Matrix Panel with shape 32x8 or 16x16\r\nload dependency\r\n\"neomatrix\": \"file:../pxt-neomatrix\"\r\n*/\r\n\r\n//% color=\"#13c2c2\" weight=10 icon=\"\\uf17a\"\r\nnamespace neomatrix {\r\n    const RGB_PIX = 256\r\n\r\n    let rgbBuf: Buffer = pins.createBuffer(RGB_PIX * 3);\r\n    let rgbPin: DigitalPin;\r\n    let matType: MatType;\r\n    let rgbBright: number = 30;\r\n\r\n    // no hex literal support for microbit v1\r\n    export function hexstr2buf(a: string): void {\r\n        for (let i = 0; i < a.length; i += 2) {\r\n            let rgb = (a.charCodeAt(i) % 32 + 9) % 25 * 16 + (a.charCodeAt(i + 1) % 32 + 9) % 25;\r\n            rgbBuf[i / 2] = (rgb * rgbBright) >> 8;\r\n        }\r\n        ws2812b.sendBuffer(rgbBuf, rgbPin);\r\n    }\r\n\r\n    export enum MatType {\r\n        //% block=32x8\r\n        m32x8 = 0,\r\n        //% block=16x16\r\n        m16x16 = 1\r\n    }\r\n\r\n    //% blockId=neomat_setpin block=\"Matrix Pin %pin %mat\"\r\n    export function SetRGBPin(pin: DigitalPin, mat: MatType): void {\r\n        rgbPin = pin;\r\n        matType = mat;\r\n        NeoMatClear();\r\n    }\r\n\r\n    //% blockId=neomat_setbright block=\"Matrix Brightness %bright\"\r\n    export function SetBright(bright: number): void {\r\n        rgbBright = bright & 0xff;\r\n    }\r\n\r\n    //% blockId=neomat_shift block=\"Matrix Shift %s delay %ms ms\"\r\n    export function ShiftMat(s: number, ms: number): void {\r\n        if (matType == MatType.m32x8) {\r\n            s = s % 32;\r\n            rgbBuf.rotate(-s * 8 * 3 * 2);\r\n            ws2812b.sendBuffer(rgbBuf, rgbPin);\r\n        }\r\n        // todo: support 16x16 shift\r\n        basic.pause(ms)\r\n    }\r\n\r\n    //% blockId=neomat_clear block=\"Clear\"\r\n    //% blockGap=70\r\n    export function NeoMatClear(): void {\r\n        rgbBuf.fill(0);\r\n        ws2812b.sendBuffer(rgbBuf, rgbPin);\r\n    }\r\n\r\n\r\n}"
}