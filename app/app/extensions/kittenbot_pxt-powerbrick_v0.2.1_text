{
  "pxt.json": "{\n    \"name\": \"powerbrick\",\n    \"version\": \"0.2.1\",\n    \"description\": \"Powerbrick series module for microbit\",\n    \"license\": \"MIT\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"ws2812b\": \"github:Microsoft/pxt-ws2812b#v0.0.4\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"main.ts\",\n        \"_locales/zh-cn/powerbrick-strings.json\",\n        \"_locales/zh-tw/powerbrick-strings.json\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true\n}",
  "README.md": "# powerbrick\r\n\r\nExtension for Kittenbot powerbrick module series\r\n\r\n## Feature\r\n\r\n----------\r\n\r\nFor more infomation please visit [http://kittenbot.cc/bbs/](http://kittenbot.cc/bbs/ \"Kittenbot BBS\")\r\n\r\n## License\r\n\r\nMIT\r\n\r\n## Supported targets\r\n\r\n* for PXT/microbit\r\n(The metadata above is needed for package search.)\r\n\r\n```package\r\npowerbrick=github:Kittenbot/pxt-powerbrick\r\n```",
  "main.ts": "/*\nRiven\nMicrobit powerbrick extension board\nload dependency\n\"powerbrick\": \"file:../pxt-powerbrick\"\ndht11 port from MonadnockSystems/pxt-dht11\nrgb pixel port from Microsoft/pxt-neopixel\n*/\n\n\n//% color=\"#13c2c2\" weight=10 icon=\"\\uf0e7\"\n//% groups='[\"Ultrasonic/Mic\", \"Linefollower\", \"Bumper\", \"Environment\", \"Actuator\", \"Color/Gesture\", \"Mp3\", \"RFID\", \"RGB\"]'\nnamespace powerbrick {\n    const PCA9685_ADDRESS = 0x40\n    const MODE1 = 0x00\n    const MODE2 = 0x01\n    const SUBADR1 = 0x02\n    const SUBADR2 = 0x03\n    const SUBADR3 = 0x04\n    const PRESCALE = 0xFE\n    const LED0_ON_L = 0x06\n    const LED0_ON_H = 0x07\n    const LED0_OFF_L = 0x08\n    const LED0_OFF_H = 0x09\n    const ALL_LED_ON_L = 0xFA\n    const ALL_LED_ON_H = 0xFB\n    const ALL_LED_OFF_L = 0xFC\n    const ALL_LED_OFF_H = 0xFD\n\n    const KC_ADDR = 0x6D\n    const KC_VERSION = 0x00\n    const KC_MODE = 1\n    const KC_READCOLOR = 21\n    const KC_READCOLORRAW = 23\n    const KC_LEDPWM = 24\n    const KC_LEDONOFF = 25\n    const KC_LEDBIT = 26\n    const KC_PROXIMITY = 31\n    const KC_GESTURE = 41\n\n    const RFID_ADDR = 0x6B\n    const RFID_VERSION = 0x00\n    const RFID_READCMD = 0x01\n    const RFID_READOUT = 0x02\n    const RFID_WRITE = 0x03\n    const RFID_STOP = 0x04\n    const RFID_STATUS = 0x05\n    const RFID_UUID = 0x06\n\n    const RGB_PIX = 64; // multiple panel support moved to neomatrix\n    const RGB_M = 8;\n\n    const FontNum = [\n        0xff81ff,\n        0x0000ff,\n        0x8f89f9,\n        0xff8989,\n        0xff080f,\n        0xf9898f,\n        0xf989ff,\n        0xff0101,\n        0xff89ff,\n        0xff898f\n    ]\n\n    enum RfidStat {\n        IDLE = 0,\n        SELECTED = 1,\n        READ_PENDING = 2,\n        READ_SUCC = 3,\n        WRITE_SUCC = 4\n    }\n\n    const PortDigi = [\n        [DigitalPin.P8, DigitalPin.P0],\n        [DigitalPin.P12, DigitalPin.P1],\n        [DigitalPin.P13, DigitalPin.P2],\n        [DigitalPin.P15, DigitalPin.P14],\n        [DigitalPin.P6, DigitalPin.P3],\n        [DigitalPin.P7, DigitalPin.P4],\n        [DigitalPin.P9, DigitalPin.P10]\n    ]\n\n    const PortSerial = [\n        [SerialPin.P8, SerialPin.P0],\n        [SerialPin.P12, SerialPin.P1],\n        [SerialPin.P13, SerialPin.P2],\n        [SerialPin.P15, SerialPin.P14]\n    ]\n\n    const PortAnalog = [\n        AnalogPin.P0,\n        AnalogPin.P1,\n        AnalogPin.P2,\n        null,\n        AnalogPin.P3,\n        AnalogPin.P4,\n        AnalogPin.P10\n    ]\n\n    export enum Ports {\n        PORT1 = 0,\n        PORT2 = 1,\n        PORT3 = 2,\n        PORT4 = 3,\n        PORT5 = 4,\n        PORT6 = 5,\n        PORT7 = 6\n    }\n\n    export enum PortsA {\n        PORT1 = 0,\n        PORT2 = 1,\n        PORT3 = 2,\n        PORT5 = 4,\n        PORT6 = 5,\n        PORT7 = 6\n    }\n\n    export enum SerialPorts {\n        PORT1 = 0,\n        PORT2 = 1,\n        PORT3 = 2,\n        PORT4 = 3\n    }\n\n    export enum PrevNext {\n        //% block=play\n        Play = 0xaa,\n        //% block=stop\n        Stop = 0xab,\n        //% block=next\n        Next = 0xac,\n        //% block=prev\n        Prev = 0xad\n    }\n\n    export enum GCLed {\n        All = 0,\n        LED1 = 1,\n        LED2 = 2,\n        LED3 = 3,\n        LED4 = 4\n    }\n\n    export enum Slots {\n        A = 0,\n        B = 1\n    }\n\n    export enum GCOnOff {\n        On = 1,\n        Off = 0\n    }\n\n    export enum DHT11Type {\n        //% block=temperature(°C)\n        TemperatureC = 0,\n        //% block=temperature(°F)\n        TemperatureF = 1,\n        //% block=humidity\n        Humidity = 2\n    }\n\n    export enum Servos {\n        S1 = 8,\n        S2 = 9,\n        S3 = 10,\n        S4 = 11,\n        S5 = 12,\n        S6 = 13,\n        S7 = 14,\n        S8 = 15,\n        S9 = 7,\n        S10 = 6,\n        S11 = 5,\n        S12 = 4\n    }\n\n    export enum RfidSector {\n        S1 = 1,\n        S2 = 2,\n        S3 = 3,\n        S4 = 4,\n        S5 = 5,\n        S6 = 6,\n        S7 = 7,\n        S8 = 8,\n        S9 = 9,\n        S10 = 10,\n        S11 = 11,\n        S12 = 12,\n        S13 = 13,\n        S14 = 14,\n        S15 = 15\n    }\n\n    export enum RfidBlock {\n        B0 = 0,\n        B1 = 1,\n        B2 = 2\n    }\n\n    export enum Motors {\n        M1 = 0x1,\n        M2 = 0x2\n    }\n\n    export enum TracerEvent {\n        InLine = DAL.MICROBIT_BUTTON_EVT_DOWN,\n        OutLine = DAL.MICROBIT_BUTTON_EVT_UP\n    }\n\n    export enum GCMode {\n        //% block=colorsensor\n        ColorSensor = 0x1,\n        //% block=proximity\n        Proximity = 0x2,\n        //% block=gesture\n        Gesture = 0x3\n    }\n\n    export enum GCRgb {\n        //% block=brightness\n        Brightness = 0,\n        //% block=red\n        Red = 1,\n        //% block=green\n        Green = 2,\n        //% block=blue\n        Blue = 3\n    }\n    export enum NeoPixelColors {\n        //% block=red\n        Red = 0xFF0000,\n        //% block=orange\n        Orange = 0xFFA500,\n        //% block=yellow\n        Yellow = 0xFFFF00,\n        //% block=green\n        Green = 0x00FF00,\n        //% block=blue\n        Blue = 0x0000FF,\n        //% block=indigo\n        Indigo = 0x4b0082,\n        //% block=violet\n        Violet = 0x8a2be2,\n        //% block=purple\n        Purple = 0xFF00FF,\n        //% block=white\n        White = 0xFFFFFF,\n        //% block=black\n        Black = 0x000000\n    }\n\n    let initialized = false\n    let distanceBuf = 0;\n    let dht11Temp = -1;\n    let dht11Humi = -1;\n\n    type EvtAct = () => void;\n    let onRfidPresent: EvtAct = null;\n    let rgbBuf: Buffer = pins.createBuffer(RGB_PIX * 3);\n    let rgbPin: DigitalPin;\n    let rgbBright: number = 30;\n\n    function setBufferRGB(offset: number, red: number, green: number, blue: number): void {\n        rgbBuf[offset + 0] = green;\n        rgbBuf[offset + 1] = red;\n        rgbBuf[offset + 2] = blue;\n    }\n\n    function dht11Update(pin: DigitalPin): number {\n        let loopCnt = 50;\n        pins.digitalWritePin(pin, 0)\n        basic.pause(18)\n        let t = pins.digitalReadPin(pin)\n        pins.setPull(pin, PinPullMode.PullUp);\n        // Wait for response header to finish\n        // dht11 only response every 2s\n        while (pins.digitalReadPin(pin) == 1) {\n            loopCnt--;\n            if (loopCnt == 0) {\n                return -1\n            }\n        };\n        loopCnt = 500;\n        while (pins.digitalReadPin(pin) == 0);\n        while (pins.digitalReadPin(pin) == 1);\n        let value: number = 0;\n        let counter = 0;\n        for (let i = 0; i <= 32 - 1; i++) {\n            while (pins.digitalReadPin(pin) == 0) {\n                loopCnt--;\n                if (loopCnt == 0) {\n                    return -1\n                }\n            };\n            counter = 0\n            while (pins.digitalReadPin(pin) == 1) {\n                counter += 1;\n                loopCnt--;\n                if (loopCnt == 0) {\n                    return -1\n                }\n            }\n            if (counter >= 3) {\n                value = value + (1 << (31 - i));\n            }\n        }\n\n        // todo: add bit check\n\n        dht11Temp = (value & 0x0000ff00) >> 8;\n        dht11Humi = value >> 24;\n        return 0;\n    }\n\n    function i2cwrite(addr: number, reg: number, value: number) {\n        let buf = pins.createBuffer(2)\n        buf[0] = reg\n        buf[1] = value\n        pins.i2cWriteBuffer(addr, buf)\n    }\n\n    function i2ccmd(addr: number, value: number) {\n        let buf = pins.createBuffer(1)\n        buf[0] = value\n        pins.i2cWriteBuffer(addr, buf)\n    }\n\n    function i2cread(addr: number, reg: number) {\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\n        return val;\n    }\n\n    function initPCA9685(): void {\n        i2cwrite(PCA9685_ADDRESS, MODE1, 0x00)\n        setFreq(50);\n        for (let idx = 0; idx < 16; idx++) {\n            setPwm(idx, 0, 0);\n        }\n        initialized = true\n    }\n\n    function setFreq(freq: number): void {\n        // Constrain the frequency\n        let prescaleval = 25000000;\n        prescaleval /= 4096;\n        prescaleval /= freq;\n        prescaleval -= 1;\n        let prescale = prescaleval; //Math.Floor(prescaleval + 0.5);\n        let oldmode = i2cread(PCA9685_ADDRESS, MODE1);\n        let newmode = (oldmode & 0x7F) | 0x10; // sleep\n        i2cwrite(PCA9685_ADDRESS, MODE1, newmode); // go to sleep\n        i2cwrite(PCA9685_ADDRESS, PRESCALE, prescale); // set the prescaler\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode);\n        control.waitMicros(5000);\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode | 0xa1);\n    }\n\n    function setPwm(channel: number, on: number, off: number): void {\n        if (channel < 0 || channel > 15)\n            return;\n        let buf = pins.createBuffer(5);\n        buf[0] = LED0_ON_L + 4 * channel;\n        buf[1] = on & 0xff;\n        buf[2] = (on >> 8) & 0xff;\n        buf[3] = off & 0xff;\n        buf[4] = (off >> 8) & 0xff;\n        pins.i2cWriteBuffer(PCA9685_ADDRESS, buf);\n    }\n\n    //% blockId=powerbrick_ultrasonic block=\"Ultrasonic|port %port\"\n    //% group=\"Ultrasonic/Mic\" weight=91\n    export function Ultrasonic(port: Ports): number {\n        // send pulse\n        let pin = PortDigi[port][0]\n        pins.setPull(pin, PinPullMode.PullNone);\n        pins.digitalWritePin(pin, 0);\n        control.waitMicros(2);\n        pins.digitalWritePin(pin, 1);\n        control.waitMicros(10);\n        pins.digitalWritePin(pin, 0);\n\n        // read pulse\n        let d = pins.pulseIn(pin, PulseValue.High, 25000);\n        let ret = d;\n        // filter timeout spikes\n        if (ret == 0 && distanceBuf != 0) {\n            ret = distanceBuf;\n        }\n        distanceBuf = d;\n        return Math.floor(ret * 10 / 6 / 58);\n    }\n\n    //% blockId=powerbrick_sound block=\"Sound|port %port\"\n    //% weight=90\n    //% group=\"Ultrasonic/Mic\" blockGap=50\n    export function SoundSensor(port: PortsA): number {\n        let pin = PortAnalog[port]\n        return pins.analogReadPin(pin)\n    }\n\n    //% blockId=powerbrick_tracer block=\"Tracer|port %port|slot %slot\"\n    //% group=\"Linefollower\" weight=81\n    export function Tracer(port: Ports, slot: Slots): boolean {\n        let pin = PortDigi[port][slot]\n        pins.setPull(pin, PinPullMode.PullUp)\n        return pins.digitalReadPin(pin) == 1\n    }\n\n    //% blockId=powerbrick_onTracerEvent block=\"on Tracer|%port|slot %slot touch black\"\n    //% weight=80\n    //% group=\"Linefollower\" blockGap=50\n    export function onTracerEvent(port: Ports, slot: Slots, handler: () => void): void {\n        let pin = PortDigi[port][slot]\n        pins.setPull(pin, PinPullMode.PullUp)\n        pins.onPulsed(pin, PulseValue.High, handler)\n    }\n\n    //% blockId=powerbrick_bumper block=\"Bumper|port %port|slot %slot\"\n    //% group=\"Bumper\" weight=71\n    export function Bumper(port: Ports, slot: Slots): boolean {\n        let pin = PortDigi[port][slot]\n        pins.setPull(pin, PinPullMode.PullUp)\n        return pins.digitalReadPin(pin) == 0\n    }\n\n    //% blockId=powerbrick_onBumperEvent block=\"on Bumper|%port|slot %slot pressed\"\n    //% group=\"Bumper\" weight=70\n    export function onBumperEvent(port: Ports, slot: Slots, handler: () => void): void {\n        let pin = PortDigi[port][slot]\n        pins.setPull(pin, PinPullMode.PullUp)\n        pins.onPulsed(pin, PulseValue.Low, handler)\n    }\n\n\n    //% blockId=powerbrick_dht11 block=\"DHT11|port %port|type %readtype\"\n    //% weight=60\n    //% group=\"Environment\" blockGap=50\n    export function DHT11(port: Ports, readtype: DHT11Type): number {\n        let pin = PortDigi[port][0]\n        dht11Update(pin)\n        if (readtype == DHT11Type.TemperatureC) {\n            return dht11Temp;\n        } else if (readtype == DHT11Type.TemperatureF) {\n            return Math.floor(dht11Temp * 9 / 5) + 32;\n        } else {\n            return dht11Humi;\n        }\n    }\n\n    //% blockId=powerbrick_soil block=\"Soil|port %port\"\n    //% weight=60\n    //% group=\"Environment\" blockGap=50\n    export function Soil(port: PortsA): number {\n        let pin = PortAnalog[port]\n        return pins.analogReadPin(pin)\n    }\n\n    //% blockId=powerbrick_waterlevel block=\"Water level |port %port\"\n    //% weight=60\n    //% group=\"Environment\" blockGap=50\n    export function WaterLevel(port: PortsA): number {\n        let pin = PortAnalog[port]\n        return pins.analogReadPin(pin)\n    }\n\n\n    //% blockId=powerbrick_servo block=\"Servo|%index|degree %degree\"\n    //% weight=50\n    //% blockGap=50\n    //% degree.min=-45 degree.max=225\n    //% group=\"Actuator\" name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function Servo(index: Servos, degree: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        // 50hz: 20,000 us\n        let v_us = ((degree - 90) * 20 / 3 + 1500) // 0.6 ~ 2.4\n        let value = v_us * 4096 / 20000\n        setPwm(index, 0, value)\n    }\n\n    //% blockId=powerbrick_motor_run block=\"Motor|%index|speed %speed\"\n    //% weight=44\n    //% speed.min=-255 speed.max=255\n    //% group=\"Actuator\" name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function MotorRun(index: Motors, speed: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        speed = speed * 16; // map 255 to 4096\n        if (speed >= 4096) {\n            speed = 4095\n        }\n        if (speed <= -4096) {\n            speed = -4095\n        }\n        if (index > 2 || index <= 0)\n            return\n        let pp = (index - 1) * 2\n        let pn = (index - 1) * 2 + 1\n        // serial.writeString(\"M \" + index + \" spd \" + speed + \" pp \" + pp + \" pn \" + pn + \"\\n\")\n        if (speed >= 0) {\n            setPwm(pp, 0, speed)\n            setPwm(pn, 0, 0)\n        } else {\n            setPwm(pp, 0, 0)\n            setPwm(pn, 0, -speed)\n        }\n    }\n\n\n    //% blockId=powerbrick_motor_dual block=\"Motor|speed %speed1|speed %speed2\"\n    //% weight=43\n    //% speed1.min=-255 speed1.max=255\n    //% speed2.min=-255 speed2.max=255\n    //% group=\"Actuator\" name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function MotorRunDual(speed1: number, speed2: number): void {\n        MotorRun(0, speed1);\n        MotorRun(1, speed2);\n    }\n\n    //% blockId=powerbrick_motor_rundelay block=\"Motor|%index|speed %speed|delay %delay|s\"\n    //% weight=42\n    //% speed.min=-255 speed.max=255\n    //% group=\"Actuator\" name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function MotorRunDelay(index: Motors, speed: number, delay: number): void {\n        MotorRun(index, speed);\n        basic.pause(delay * 1000);\n        MotorRun(index, 0);\n    }\n\n    //% blockId=powerbrick_stop block=\"Motor Stop|%index|\"\n    //% group=\"Actuator\" weight=41\n    export function MotorStop(index: Motors): void {\n        MotorRun(index, 0);\n    }\n\n    //% blockId=powerbrick_stop_all block=\"Motor Stop All\"\n    //% weight=40\n    //% group=\"Actuator\" blockGap=50\n    export function MotorStopAll(): void {\n        MotorRun(1, 0);\n        MotorRun(2, 0);\n    }\n\n    function calcSum(buf: Buffer, start: number, end: number): number {\n        let sum = 0;\n        for (let i = start; i <= end; i++) {\n            sum += buf[i];\n        }\n        return sum;\n    }\n\n    //% blockId=powerbrick_mp3_connect block=\"MP3 Connect|port %port\"\n    //% group=\"MP3\" weight=39\n    export function MP3Connect(port: SerialPorts): void {\n        let pin0 = PortSerial[port][0]\n        let pin1 = PortSerial[port][1]\n        // todo: fiber may freeze on steam reading\n        serial.redirect(pin1, SerialPin.P16, BaudRate.BaudRate9600)\n    }\n\n    //% blockId=powerbrick_mp3_play block=\"MP3 Play|%PrevNext\"\n    //% group=\"MP3\" weight=38\n    export function MP3Play(pn: PrevNext): void {\n        let buf = pins.createBuffer(5);\n        buf[0] = 0x7e;\n        buf[1] = 0x03;\n        buf[2] = pn;\n        buf[3] = buf[1] + buf[2];\n        buf[4] = 0xef;\n        serial.writeBuffer(buf)\n    }\n\n    //% blockId=powerbrick_mp3_volumn block=\"MP3 Volumn|%volumn\"\n    //% volumn.min=0 volumn.max=31\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    //% group=\"MP3\" weight=37\n    export function MP3Volumn(volumn: number): void {\n        let buf = pins.createBuffer(6);\n        buf[0] = 0x7e;\n        buf[1] = 0x04;\n        buf[2] = 0xae;\n        buf[3] = volumn;\n        buf[4] = calcSum(buf, 1, 3);\n        buf[5] = 0xef;\n        serial.writeBuffer(buf)\n    }\n\n    //% blockId=powerbrick_mp3_playindex block=\"MP3 Play Index|%index\"\n    //% group=\"MP3\" weight=37\n    export function MP3PlayIndex(index: number): void {\n        let buf = pins.createBuffer(7);\n        if (index == 0) {\n            index = 1;\n        }\n        buf[0] = 0x7e;\n        buf[1] = 0x05;\n        buf[2] = 0xa2;\n        buf[3] = 0;\n        buf[4] = index;\n        buf[5] = calcSum(buf, 1, 4);\n        buf[6] = 0xef;\n        serial.writeBuffer(buf)\n    }\n\n    //% blockId=powerbrick_mp3_playname block=\"MP3 Play Name|%name\"\n    //% weight=36\n    //% group=\"MP3\" blockGap=50\n    export function MP3PlayName(str: string): void {\n        let len = str.length;\n        if (len > 8) len = 8;\n        let buf = pins.createBuffer(len + 5);\n        buf[0] = 0x7e;\n        buf[1] = len + 3;\n        buf[2] = 0xa3;\n        for (let i = 0; i < len; i++) {\n            buf[3 + i] = str.charCodeAt(i);\n        }\n        buf[len + 3] = calcSum(buf, 1, len + 2);\n        buf[len + 4] = 0xef;\n        serial.writeBuffer(buf)\n    }\n\n    //% blockId=powerbrick_gc_mode block=\"Gesture/Color mode|%mode\"\n    //% group=\"Color/Gesture\" weight=29\n    export function GC_MODE(mode: GCMode): void {\n        i2cwrite(KC_ADDR, KC_MODE, mode);\n    }\n\n    //% blockId=powerbrick_gc_color block=\"Gesture/Color Color Hue\"\n    //% group=\"Color/Gesture\" weight=28\n    export function GC_Color(): number {\n        pins.i2cWriteNumber(KC_ADDR, KC_READCOLOR, NumberFormat.UInt8BE);\n        let buff = pins.i2cReadBuffer(KC_ADDR, 2);\n        return buff[0] * 2;\n    }\n\n    //% blockId=powerbrick_gc_brightness block=\"Gesture/Color Brightness\"\n    //% group=\"Color/Gesture\" weight=27\n    export function GC_Brightness(): number {\n        pins.i2cWriteNumber(KC_ADDR, KC_READCOLOR, NumberFormat.UInt8BE);\n        let buff = pins.i2cReadBuffer(KC_ADDR, 2);\n        return buff[1];\n    }\n\n    //% blockId=powerbrick_gc_ledpwm block=\"Gesture/Color LED Brightness|%pwm\"\n    //% pwm.min=0 pwm.max=255\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    //% group=\"Color/Gesture\" weight=26\n    export function GC_LEDPWM(pwm: number): void {\n        i2cwrite(KC_ADDR, KC_LEDPWM, pwm);\n    }\n\n    //% blockId=powerbrick_gc_ledonoff block=\"Gesture/Color LED|%index|On/Off %onoff\"\n    //% group=\"Color/Gesture\" weight=25\n    export function GC_LEDONOFF(index: GCLed, onoff: GCOnOff): void {\n        let buf = pins.createBuffer(3)\n        buf[0] = KC_LEDONOFF\n        buf[1] = index\n        buf[2] = onoff\n        pins.i2cWriteBuffer(KC_ADDR, buf)\n        basic.pause(1)\n    }\n\n    //% blockId=powerbrick_gc_ledbit block=\"Gesture/Color|LED1 %l1|LED2 %l2|LED3 %l3|LED4 %l4\"\n    //% group=\"Color/Gesture\" weight=24\n    export function GC_LEDBIT(l1: GCOnOff, l2: GCOnOff, l3: GCOnOff, l4: GCOnOff): void {\n        let buf = pins.createBuffer(2)\n        buf[0] = KC_LEDBIT\n        buf[1] = l1 * 1 + l2 * 2 + l3 * 4 + l4 * 8;\n        pins.i2cWriteBuffer(KC_ADDR, buf)\n        basic.pause(1)\n    }\n\n    //% blockId=powerbrick_gc_proximity block=\"Gesture/Color Proximity\"\n    //% group=\"Color/Gesture\" weight=23\n    export function GC_PROXIMITY(): number {\n        return i2cread(KC_ADDR, KC_PROXIMITY)\n    }\n\n    //% blockId=powerbrick_gc_gesture block=\"Gesture/Color last gesture\"\n    //% group=\"Color/Gesture\" weight=22\n    export function GC_Gesture(): number {\n        return i2cread(KC_ADDR, KC_GESTURE)\n    }\n\n    //% blockId=powerbrick_gc_rgb block=\"Gesture/Color RGB|%rgb\"\n    //% group=\"Color/Gesture\" weight=21\n    //% blockGap = 50\n    export function GC_RGB(rgb: GCRgb): number {\n        pins.i2cWriteNumber(KC_ADDR, KC_READCOLORRAW, NumberFormat.UInt8BE);\n        let buff = pins.i2cReadBuffer(KC_ADDR, 4);\n        return buff[rgb];\n    }\n\n    //% blockId=powerbrick_rfidprobe block=\"RFID Probe\"\n    //% weight=21\n    //% group=\"RFID\" \n    export function RfidProbe(): void {\n        let stat = i2cread(RFID_ADDR, RFID_STATUS);\n        if (stat == 1) {\n            if (onRfidPresent) {\n                onRfidPresent();\n                RfidStop();\n            }\n        }\n    }\n\n    //% blockId=powerbrick_onrfidpresent block=\"RFID Present and wait\"\n    //% weight=20\n    //% group=\"RFID\" \n    export function RfidPresent(handler: () => void): void {\n        onRfidPresent = handler;\n    }\n\n    //% blockId=powerbrick_rfiduuid block=\"RFID UUID\"\n    //% weight=19\n    //% group=\"RFID\"\n    export function RfidUUID(): string {\n        pins.i2cWriteNumber(RFID_ADDR, RFID_UUID, NumberFormat.UInt8BE);\n        let uuid = pins.i2cReadBuffer(RFID_ADDR, 4)\n        return uuid.toHex();\n    }\n\n    //% blockId=powerbrick_rfidwrite block=\"RFID Write sector|%sector block|%block text|%txt\"\n    //% weight=18\n    //% group=\"RFID\" \n    export function RfidWrite(sector: RfidSector, block: RfidBlock, txt: string): void {\n        let buf = pins.createBuffer(19)\n        buf[0] = RFID_WRITE\n        buf[1] = sector\n        buf[2] = block\n        let len = txt.length\n        if (len > 16) len = 16\n        for (let i = 0; i < len; i++) {\n            buf[3 + i] = txt.charCodeAt(i)\n        }\n        pins.i2cWriteBuffer(RFID_ADDR, buf)\n        basic.pause(100)\n    }\n\n    //% blockId=powerbrick_rfidread block=\"RFID Read sector|%sector block|%block\"\n    //% weight=17\n    //% group=\"RFID\" \n    export function RfidRead(sector: RfidSector, block: RfidBlock): string {\n        let retry: number = 5;\n        let buf = pins.createBuffer(3)\n        buf[0] = RFID_READCMD\n        buf[1] = sector\n        buf[2] = block\n        pins.i2cWriteBuffer(RFID_ADDR, buf)\n\n        while (retry) {\n            basic.pause(100);\n            let stat = i2cread(RFID_ADDR, RFID_STATUS);\n            if (stat == RfidStat.READ_SUCC) {\n                let ret = '';\n                pins.i2cWriteNumber(RFID_ADDR, RFID_READOUT, NumberFormat.UInt8BE);\n                let rxbuf = pins.i2cReadBuffer(RFID_ADDR, 16)\n                for (let i = 0; i < 16; i++) {\n                    if (rxbuf[i] >= 0x20 && rxbuf[i] < 0x7f) {\n                        ret += String.fromCharCode(rxbuf[i]) // valid ascii\n                    }\n                }\n                return ret;\n            }\n            retry--;\n        }\n        return '';\n    }\n\n\n    function RfidStop(): void {\n        let buf = pins.createBuffer(1)\n        buf[0] = RFID_STOP\n        pins.i2cWriteBuffer(RFID_ADDR, buf)\n    }\n\n\n    //% blockId=\"powerbrick_rgbattach\" block=\"RGB connect ot %port\"\n    //% weight=85 blockGap=8\n    //% group=\"RGB\"\n    export function rgbConnect(port: Ports) {\n        rgbPin = PortDigi[port][0];\n    }\n\n    /**\n     * Shows a rainbow pattern on all LEDs. \n     * @param startHue the start hue value for the rainbow, eg: 1\n     * @param endHue the end hue value for the rainbow, eg: 360\n     */\n    //% blockId=\"powerbrick_rgbrainbow\" block=\"show rainbow from %startHue|to %endHue\"\n    //% weight=85 blockGap=8\n    //% group=\"RGB\" \n    export function showRainbow(startHue: number = 1, endHue: number = 360) {\n        const saturation = 100;\n        const luminance = 50;\n        const steps = RGB_PIX;\n\n        //hue\n        const h1 = startHue;\n        const h2 = endHue;\n        const hDistCW = ((h2 + 360) - h1) % 360;\n        const hStepCW = Math.idiv((hDistCW * 100), steps);\n        const hDistCCW = ((h1 + 360) - h2) % 360;\n        const hStepCCW = Math.idiv(-(hDistCCW * 100), steps);\n        let hStep: number;\n        hStep = hStepCW;\n\n        const h1_100 = h1 * 100; //we multiply by 100 so we keep more accurate results while doing interpolation\n        //sat\n        const s1 = saturation;\n        const s2 = saturation;\n        const sDist = s2 - s1;\n        const sStep = Math.idiv(sDist, steps);\n        const s1_100 = s1 * 100;\n\n        //lum\n        const l1 = luminance;\n        const l2 = luminance;\n        const lDist = l2 - l1;\n        const lStep = Math.idiv(lDist, steps);\n        const l1_100 = l1 * 100\n\n        //interpolate\n\n        setPixelRGB(0, hsl(startHue, saturation, luminance));\n        for (let i = 1; i < steps - 1; i++) {\n            const h = Math.idiv((h1_100 + i * hStep), 100) + 360;\n            const s = Math.idiv((s1_100 + i * sStep), 100);\n            const l = Math.idiv((l1_100 + i * lStep), 100);\n            setPixelRGB(i, hsl(h, s, l));\n        }\n        setPixelRGB(steps - 1, hsl(endHue, saturation, luminance));\n        rgbShow();\n    }\n\n    //% blockId=\"neopixel_set_strip_color\" block=\"show color %rgb=neopixel_colors\"\n    //% weight=85 blockGap=8\n    //% group=\"RGB\" \n    export function showColor(rgb: number) {\n        let red = unpackR(rgb);\n        let green = unpackG(rgb);\n        let blue = unpackB(rgb);\n\n        const br = rgbBright;\n        if (br < 255) {\n            red = (red * br) >> 8;\n            green = (green * br) >> 8;\n            blue = (blue * br) >> 8;\n        }\n        for (let i = 0; i < 64; ++i) {\n            setBufferRGB(i * 3, red, green, blue)\n        }\n\n        rgbShow();\n    }\n\n    /**\n     * Converts a hue saturation luminosity value into a RGB color\n     * @param h hue from 0 to 360\n     * @param s saturation from 0 to 99\n     * @param l luminosity from 0 to 99\n     */\n    //% blockId=neopixelHSL block=\"hue %h|saturation %s|luminosity %l\"\n    //% group=\"RGB\" \n    export function hsl(h: number, s: number, l: number): number {\n        h = Math.round(h);\n        s = Math.round(s);\n        l = Math.round(l);\n\n        h = h % 360;\n        s = Math.clamp(0, 99, s);\n        l = Math.clamp(0, 99, l);\n        let c = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) << 8), 10000); //chroma, [0,255]\n        let h1 = Math.idiv(h, 60);//[0,6]\n        let h2 = Math.idiv((h - h1 * 60) * 256, 60);//[0,255]\n        let temp = Math.abs((((h1 % 2) << 8) + h2) - 256);\n        let x = (c * (256 - (temp))) >> 8;//[0,255], second largest component of this color\n        let r$: number;\n        let g$: number;\n        let b$: number;\n        if (h1 == 0) {\n            r$ = c; g$ = x; b$ = 0;\n        } else if (h1 == 1) {\n            r$ = x; g$ = c; b$ = 0;\n        } else if (h1 == 2) {\n            r$ = 0; g$ = c; b$ = x;\n        } else if (h1 == 3) {\n            r$ = 0; g$ = x; b$ = c;\n        } else if (h1 == 4) {\n            r$ = x; g$ = 0; b$ = c;\n        } else if (h1 == 5) {\n            r$ = c; g$ = 0; b$ = x;\n        }\n        let m = Math.idiv((Math.idiv((l * 2 << 8), 100) - c), 2);\n        let r = r$ + m;\n        let g = g$ + m;\n        let b = b$ + m;\n        return packRGB(r, g, b);\n    }\n\n    //% blockId=\"neopixel_clear\" block=\"RGB clear\"\n    //% group=\"RGB\" \n    export function rgbClear(): void {\n        rgbBuf.fill(0, 0, RGB_PIX * 3);\n        rgbShow();\n    }\n\n    //% blockId=setRGBPix block=\"RGB PIX%pix Color%rgb=neopixel_colors\"\n    //% group=\"RGB\" \n    export function setRGBPix(pix: number, rgb: number): void {\n        if (pix < 0 || pix >= RGB_PIX)\n            return;\n        pix = pixMap(pix);\n        pix = (pix) * 3;\n\n        let red = unpackR(rgb);\n        let green = unpackG(rgb);\n        let blue = unpackB(rgb);\n\n        let br = rgbBright;\n        if (br < 255) {\n            red = (red * br) >> 8;\n            green = (green * br) >> 8;\n            blue = (blue * br) >> 8;\n        }\n        setBufferRGB(pix, red, green, blue)\n    }\n\n    //% blockId=setRGBXy block=\"RGB X%x Y%y Color%rgb=neopixel_colors\"\n    //% group=\"RGB\" \n    export function setRGBXy(x: number, y: number, rgb: number): void {\n        setRGBPix(x + y * RGB_M, rgb)\n    }\n\n    //% blockId=showNum block=\"Show number %num Color%rgb=neopixel_colors\"\n    //% group=\"RGB\" blockGap=16\n    export function showNum(num: number, rgb: number): void {\n        num = num % 100;\n        let n1 = Math.floor(num / 10);\n        let n0 = num % 10;\n        let pix = 0;\n        rgbBuf.fill(0, 0, RGB_PIX * 3);\n        if (n1 > 0) {\n            pix = FontNum[n1];\n            for (let x = 0; x < 3; x++) {\n                let p = (pix >> x * 8) & 0xff;\n                for (let y = 0; y < 8; y++) {\n                    if ((p >> y) & 1) {\n                        setRGBXy(x + 1, y, rgb)\n                    }\n                }\n            }\n        }\n\n        pix = FontNum[n0];\n        for (let x = 0; x < 3; x++) {\n            let p = (pix >> x * 8) & 0xff;\n            for (let y = 0; y < 8; y++) {\n                if ((p >> y) & 1) {\n                    setRGBXy(x + 5, y, rgb)\n                }\n            }\n        }\n        rgbShow()\n    }\n\n    //% blockId=neopixel_colors block=\"%color\"\n    //% group=\"RGB\" \n    export function colors(color: NeoPixelColors): number {\n        return color;\n    }\n\n    //% blockId=rgbColor block=\"Color red %red|green %green|blue %blue\"\n    //% group=\"RGB\" \n    export function rgb(red: number, green: number, blue: number): number {\n        return packRGB(red, green, blue);\n    }\n\n    //% blockId=rgbBrightness block=\"RGB brightness %brightness\"\n    //% group=\"RGB\" blockGap=16\n    export function setBrightness(brightness: number): void {\n        rgbBright = brightness & 0xff\n    }\n\n    //% blockId=rgbPixRotate block=\"rotate pixels by %offset\"\n    //% group=\"RGB\" \n    export function rgbPixRotate(offset: number = 1): void {\n        rgbBuf.rotate(-offset * 3, 0, 64 * 3)\n    }\n\n    //% blockId=rgbShow block=\"RGB show\"\n    //% group=\"RGB\" \n    export function rgbShow() {\n        ws2812b.sendBuffer(rgbBuf, rgbPin);\n    }\n\n    /*\n    export enum RGBIconName {\n        //% block=\"riven\"\n        //% blockImage=1\n        //% iconURL=\"https://kittenbot.cn/bbs/uc_server/avatar.php?uid=2&size=middle\"\n        riven = 0,\n    }\n    \n\n    //% blockId=rgb_show_icon\n    //% block=\"show icon %i\"\n    //% group=\"RGB\" \n    //% i.fieldEditor=\"gridpicker\"\n    //% i.fieldOptions.width=\"400\" i.fieldOptions.columns=\"5\"\n    //% i.fieldOptions.itemColour=\"black\" i.fieldOptions.tooltips=\"true\"\n    export function showIcon(icon: RGBIconName, interval = 600) {\n\n    }\n    */\n\n    function pinMap(x: number, y: number): number {\n        let t = y;\n        y = x; x = t;\n        if (y % 2 == 1) { // s-type connection on hardware\n            x = RGB_M - x - 1;\n        }\n        let pix = y * RGB_M + x;\n        return pix\n    }\n\n    function pixMap(pix: number): number {\n        let x = pix % RGB_M;\n        let y = Math.floor(pix / RGB_M);\n        return pinMap(x, y)\n    }\n\n\n    function setPixelRGB(pixeloffset: number, rgb: number): void {\n        if (pixeloffset < 0 || pixeloffset >= RGB_PIX)\n            return;\n\n        let stride = 3;\n        pixeloffset = (pixeloffset) * stride;\n\n        let red = unpackR(rgb);\n        let green = unpackG(rgb);\n        let blue = unpackB(rgb);\n\n        let br = rgbBright;\n        if (br < 255) {\n            red = (red * br) >> 8;\n            green = (green * br) >> 8;\n            blue = (blue * br) >> 8;\n        }\n        setBufferRGB(pixeloffset, red, green, blue)\n    }\n\n\n    function packRGB(a: number, b: number, c: number): number {\n        return ((a & 0xFF) << 16) | ((b & 0xFF) << 8) | (c & 0xFF);\n    }\n\n    function unpackR(rgb: number): number {\n        let r = (rgb >> 16) & 0xFF;\n        return r;\n    }\n    function unpackG(rgb: number): number {\n        let g = (rgb >> 8) & 0xFF;\n        return g;\n    }\n    function unpackB(rgb: number): number {\n        let b = (rgb) & 0xFF;\n        return b;\n    }\n\n\n    //% blockId=powerbrick_getpin block=\"Digital port|%port slot|%slot\"\n    //% advanced=true\n    export function GetPin(port: Ports, slot: Slots): DigitalPin {\n        return pins.digitalReadPin(PortDigi[port][slot])\n    }\n\n    //% blockId=powerbrick_getanalog block=\"Analog port|%port\"\n    //% advanced=true\n    export function GetAnalog(port: PortsA): AnalogPin {\n        return pins.analogReadPin(PortAnalog[port])\n    }\n\n}\n\n",
  "_locales/zh-cn/powerbrick-strings.json": "{\n    \"powerbrick.Ultrasonic|block\": \"超声波|端口 %port\",\n    \"powerbrick.SoundSensor|block\": \"声音强度|端口 %port\",\n    \"powerbrick.Tracer|block\": \"巡线|端口 %port|插槽 %slot\",\n    \"powerbrick.onTracerEvent|block\": \"当巡线|%port|插槽 %slot 遇黑线时\",\n    \"powerbrick.Bumper|block\": \"开关|端口 %port|插槽 %slot\",\n    \"powerbrick.onBumperEvent|block\": \"当开关|端口 %port|插槽 %slot 被按下时\",\n    \"powerbrick.DHT11|block\": \"DHT11温度|端口 %port|类型 %readtype\",\n    \"powerbrick.Soil|block\": \"土壤传感器|端口 %port\",\n    \"powerbrick.WaterLevel|block\": \"水位传感器|端口 %port\",\n    \"powerbrick.Servo|block\": \"舵机|%index|角度 %degree\",\n    \"powerbrick.MotorRun|block\": \"电机|%index|速度 %speed\",\n    \"powerbrick.MotorRunDual|block\": \"双电机|速度 %speed1|速度 %speed2\",\n    \"powerbrick.MotorRunDelay|block\": \"电机|%index|速度 %speed|延时 %delay|秒\",\n    \"powerbrick.MotorStop|block\": \"电机 %index|停止\",\n    \"powerbrick.MotorStopAll|block\": \"所有电机停止\",\n    \"powerbrick.MP3Connect|block\": \"MP3 连接|端口 %port\",\n    \"powerbrick.MP3Play|block\": \"MP3 播放|%PrevNext\",\n    \"powerbrick.MP3Volumn|block\": \"MP3 音量|%volumn\",\n    \"powerbrick.MP3PlayIndex|block\": \"MP3 播放 序号|%index\",\n    \"powerbrick.MP3PlayName|block\": \"MP3 播放 名称|%name\",\n    \"powerbrick.GC_MODE|block\": \"手势/颜色 模式|%mode\",\n    \"powerbrick.GC_Color|block\": \"手势/颜色 色环角度\",\n    \"powerbrick.GC_Brightness|block\": \"手势/颜色 亮度\",\n    \"powerbrick.GC_LEDPWM|block\": \"手势/颜色 LED 亮度|%pwm\",\n    \"powerbrick.GC_LEDONOFF|block\": \"手势/颜色 LED|%index|亮/灭 %onoff\",\n    \"powerbrick.GC_LEDBIT|block\": \"手势/颜色|LED1 %l1|LED2 %l2|LED3 %l3|LED4 %l4\",\n    \"powerbrick.GC_PROXIMITY|block\": \"手势/颜色 距离\",\n    \"powerbrick.GC_Gesture|block\": \"手势/颜色 上一个手势\",\n    \"powerbrick.GC_RGB|block\": \"手势/颜色 RGB|%rgb\",\n    \"powerbrick.RfidProbe|block\": \"RFID 开始检测\",\n    \"powerbrick.RfidPresent|block\": \"RFID 检测到卡片并等待\",\n    \"powerbrick.RfidWrite|block\": \"RFID写 区|%sector 块|%block 文本|%txt\",\n    \"powerbrick.RfidRead|block\": \"RFID读 区|%sector 块|%block\",\n    \"powerbrick.rgbConnect|block\": \"RGB 连接到 %port\",\n    \"powerbrick.showRainbow|block\": \"霓虹效果 从 %startHue|到 %endHue\",\n    \"powerbrick.showColor|block\": \"显示颜色 %rgb=neopixel_colors\",\n    \"powerbrick.rgbClear|block\": \"RGB 清屏\",\n    \"powerbrick.setRGBPix|block\": \"RGB 像素%pix 颜色%rgb=neopixel_colors\",\n    \"powerbrick.setRGBXy|block\": \"RGB X%x Y%y 颜色%rgb=neopixel_colors\",\n    \"powerbrick.rgb|block\": \"颜色 红 %red|绿 %green|蓝 %blue\",\n    \"powerbrick.rgbShow|block\": \"RGB 显示刷新\",\n    \"powerbrick.DHT11Type.TemperatureC|block\": \"温度(°C)\",\n    \"powerbrick.DHT11Type.TemperatureF|block\": \"温度(°F)\",\n    \"powerbrick.DHT11Type.Humidity|block\": \"湿度\",\n    \"powerbrick.PrevNext.Play|block\": \"播放\",\n    \"powerbrick.PrevNext.Stop|block\": \"停止\",\n    \"powerbrick.PrevNext.Prev|block\": \"前一首\",\n    \"powerbrick.PrevNext.Next|block\": \"下一首\",\n    \"powerbrick.GCMode.ColorSensor|block\": \"颜色模式\",\n    \"powerbrick.GCMode.Proximity|block\": \"近距模式\",\n    \"powerbrick.GCMode.Gesture|block\": \"手势模式\",\n    \"powerbrick.GCRgb.Brightness|block\": \"亮度\",\n    \"powerbrick.GCRgb.Red|block\": \"红\",\n    \"powerbrick.GCRgb.Green|block\": \"绿\",\n    \"powerbrick.GCRgb.Blue|block\": \"蓝\",\n    \"powerbrick.NeoPixelColors.Red|block\": \"红\",\n    \"powerbrick.NeoPixelColors.Orange|block\": \"橙\",\n    \"powerbrick.NeoPixelColors.Yellow|block\": \"黄\",\n    \"powerbrick.NeoPixelColors.Green|block\": \"緑\",\n    \"powerbrick.NeoPixelColors.Blue|block\": \"蓝\",\n    \"powerbrick.NeoPixelColors.Indigo|block\": \"靛蓝\",\n    \"powerbrick.NeoPixelColors.Violet|block\": \"紫罗兰\",\n    \"powerbrick.NeoPixelColors.Purple|block\": \"紫\",\n    \"powerbrick.NeoPixelColors.White|block\": \"白\",\n    \"powerbrick.NeoPixelColors.Black|block\": \"黑\"\n}",
  "_locales/zh-tw/powerbrick-strings.json": "{\r\n    \"powerbrick.Ultrasonic|block\": \"超聲波|接口 %port\",\r\n    \"powerbrick.SoundSensor|block\": \"聲音強度|接口 %port\",\r\n    \"powerbrick.Tracer|block\": \"巡線|接口 %port|插槽 %slot\",\r\n    \"powerbrick.onTracerEvent|block\": \"當巡線|%port|插槽 %slot 遇黑線時\",\r\n    \"powerbrick.Bumper|block\": \"開關|接口 %port|插槽 %slot\",\r\n    \"powerbrick.onBumperEvent|block\": \"當開關|接口 %port|插槽 %slot 被按下時\",\r\n    \"powerbrick.DHT11|block\": \"DHT11溫度|接口 %port|類型 %readtype\",\r\n    \"powerbrick.Soil|block\": \"土壤感應器|接口 %port\",\r\n    \"powerbrick.WaterLevel|block\": \"水位感應器|接口 %port\",\r\n    \"powerbrick.Servo|block\": \"舵機|%index|角度 %degree\",\r\n    \"powerbrick.MotorRun|block\": \"馬達|%index|速度 %speed\",\r\n    \"powerbrick.MotorRunDual|block\": \"雙馬達|速度 %speed1|速度 %speed2\",\r\n    \"powerbrick.MotorRunDelay|block\": \"馬達|%index|速度 %speed|延時 %delay|秒\",\r\n    \"powerbrick.MotorStop|block\": \"馬達 %index|停止\",\r\n    \"powerbrick.MotorStopAll|block\": \"所有馬達停止\",\r\n    \"powerbrick.MP3Connect|block\": \"MP3 連接|接口 %port\",\r\n    \"powerbrick.MP3Play|block\": \"MP3 播放|%PrevNext\",\r\n    \"powerbrick.MP3Volumn|block\": \"MP3 音量|%volumn\",\r\n    \"powerbrick.MP3PlayIndex|block\": \"MP3 播放 序號|%index\",\r\n    \"powerbrick.MP3PlayName|block\": \"MP3 播放 名稱|%name\",\r\n    \"powerbrick.GC_MODE|block\": \"手勢/顏色 模式|%mode\",\r\n    \"powerbrick.GC_Color|block\": \"手勢/顏色 色環角度\",\r\n    \"powerbrick.GC_Brightness|block\": \"手勢/顏色 亮度\",\r\n    \"powerbrick.GC_LEDPWM|block\": \"手勢/顏色 LED 亮度|%pwm\",\r\n    \"powerbrick.GC_LEDONOFF|block\": \"手勢/顏色 LED|%index|亮/滅 %onoff\",\r\n    \"powerbrick.GC_LEDBIT|block\": \"手勢/顏色|LED1 %l1|LED2 %l2|LED3 %l3|LED4 %l4\",\r\n    \"powerbrick.GC_PROXIMITY|block\": \"手勢/顏色 距離\",\r\n    \"powerbrick.GC_Gesture|block\": \"手勢/顏色 上一個手勢\",\r\n    \"powerbrick.GC_RGB|block\": \"手勢/顏色 RGB|%rgb\",\r\n    \"powerbrick.RfidProbe|block\": \"RFID 開始檢測\",\r\n    \"powerbrick.RfidPresent|block\": \"RFID 檢測到卡片\",\r\n    \"powerbrick.RfidWrite|block\": \"RFID寫 區|%sector 塊|%block 文本|%txt\",\r\n    \"powerbrick.RfidRead|block\": \"RFID讀 區|%sector 塊|%block\",\r\n    \"powerbrick.showRainbow|block\": \"霓虹效果 從 %startHue|到 %endHue\",\r\n    \"powerbrick.rgbClear|block\": \"RGB 清屏\",\r\n    \"powerbrick.setRGBPix|block\": \"RGB 像素%pix 顏色%rgb\",\r\n    \"powerbrick.setRGBXy|block\": \"RGB X%x Y%y 顏色%rgb\",\r\n    \"powerbrick.rgb|block\": \"顏色 紅 %red|綠 %green|藍 %blue\",\r\n    \"powerbrick.rgbShow|block\": \"RGB 顯示刷新\",\r\n    \"powerbrick.DHT11Type.TemperatureC|block\": \"溫度(°C)\",\r\n    \"powerbrick.DHT11Type.TemperatureF|block\": \"溫度(°F)\",\r\n    \"powerbrick.DHT11Type.Humidity|block\": \"濕度\",\r\n    \"powerbrick.PrevNext.Play|block\": \"播放\",\r\n    \"powerbrick.PrevNext.Stop|block\": \"停止\",\r\n    \"powerbrick.PrevNext.Prev|block\": \"上一首\",\r\n    \"powerbrick.PrevNext.Next|block\": \"下一首\",\r\n    \"powerbrick.GCMode.ColorSensor|block\": \"顏色模式\",\r\n    \"powerbrick.GCMode.Proximity|block\": \"近距模式\",\r\n    \"powerbrick.GCMode.Gesture|block\": \"手勢模式\",\r\n    \"powerbrick.GCRgb.Brightness|block\": \"亮度\",\r\n    \"powerbrick.GCRgb.Red|block\": \"紅\",\r\n    \"powerbrick.GCRgb.Green|block\": \"綠\",\r\n    \"powerbrick.GCRgb.Blue|block\": \"藍\",\r\n    \"NeoPixelColors.Red|block\": \"紅\",\r\n    \"NeoPixelColors.Orange|block\": \"橙\",\r\n    \"NeoPixelColors.Yellow|block\": \"黃\",\r\n    \"NeoPixelColors.Green|block\": \"綠\",\r\n    \"NeoPixelColors.Blue|block\": \"藍\",\r\n    \"NeoPixelColors.Indigo|block\": \"靛藍\",\r\n    \"NeoPixelColors.Violet|block\": \"紫羅蘭\",\r\n    \"NeoPixelColors.Purple|block\": \"紫\",\r\n    \"NeoPixelColors.White|block\": \"白\",\r\n    \"NeoPixelColors.Black|block\": \"黑\"\r\n}\r\n\r\n",
  "test.ts": "// tests go here; this will not be compiled when this package is used as a library\n"
}