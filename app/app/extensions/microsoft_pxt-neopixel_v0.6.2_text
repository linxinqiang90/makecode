{
  "pxt.json": "{\n    \"name\": \"neopixel\",\n    \"version\": \"0.6.2\",\n    \"description\": \"AdaFruit NeoPixel driver\",\n    \"license\": \"MIT\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"ws2812b\": \"github:Microsoft/pxt-ws2812b#v0.0.4\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"neopixel.ts\",\n        \"_locales/ja/neopixel-strings.json\"\n    ],\n    \"testFiles\": [\n        \"neotest.ts\"\n    ],\n    \"yotta\": {\n        \"config\": {\n            \"microbit-dal\": {\n                \"bluetooth\": {\n                    \"enabled\": 0\n                }\n            }\n        }\n    },\n    \"public\": true\n}",
  "README.md": "# NeoPixel driver\n\nThis library provides a driver for various Neo Pixel LED strips, \nsee https://www.adafruit.com/category/168\n\nNeoPixels consist of programmable RGB LEDs (WS2812, WS2812B), every one of them controlled\nseparately.  \n\n## Basic usage\n\n```blocks\n// Create a NeoPixel driver - specify the pin, number of LEDs, and the type of \n// the NeoPixel srip, either standard RGB (with GRB or RGB format) or RGB+White.\nlet strip = neopixel.create(DigitalPin.P0, 24, NeoPixelMode.RGB);\n\n// set pixel colors\nstrip.setPixelColor(0, NeoPixelColors.White); // white\nstrip.setPixelColor(1, 0xff0000);     // red\nstrip.setPixelColor(2, 0x00ff00);     // green\nstrip.setPixelColor(3, NeoPixelColors.Blue);    // blue\n\n// send the data to the strip\nstrip.show()\n```\n\nUse ``||setBrightness||`` to lower the brightness (it's maxed out by default).\n\nUse ``||shift||`` or ``||rotate||`` to shift the lights around.\n\nUse ``||setPixelWhiteLED||`` to set brightness of the white pixel for RGB+W strips. \n\n## HSL color format\n\nUse `neopixel.hslToRgb()` to create colors using hue, saturation, and lightness.\n\n## Example: Using accelerometer to control colors\n\nThis little program will let the position of the microbit control the color of the first LED.\nThis first LED will then get shifted further away every 100ms.\n\n```blocks\nlet strip = neopixel.create(DigitalPin.P0, 24, NeoPixelMode.RGB_RGB)\nwhile (true) {\n    let x = input.acceleration(Dimension.X) / 2;\n    let y = input.acceleration(Dimension.Y) / 2;\n    let z = input.acceleration(Dimension.Z) / 2;\n    strip.setPixelColor(0, neopixel.rgb(x, y, -z));\n    strip.shift(1);\n    strip.show();\n    basic.pause(100);\n}\n```\n\n## Power estimate\n\nCall ``writePowerToSerial`` to print an estimate of the current used by the pixels for the given colors.\n\n```blocks\nlet strip = neopixel.create(DigitalPin.P0, 24, NeoPixelMode.RGB_RGB)\nwhile(true) {\n    strip.show();\n    strip.writePowerToSerial();\n}\n```\n\n## Supported targets\n\n* for PXT/microbit\n* for PXT/calliope\n\n## License\n\nMIT\n\n## Code of Conduct\n\nThis project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/). For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.\n",
  "neopixel.ts": "/**\n * Well known colors for a NeoPixel strip\n */\nenum NeoPixelColors {\n    //% block=red\n    Red = 0xFF0000,\n    //% block=orange\n    Orange = 0xFFA500,\n    //% block=yellow\n    Yellow = 0xFFFF00,\n    //% block=green\n    Green = 0x00FF00,\n    //% block=blue\n    Blue = 0x0000FF,\n    //% block=indigo\n    Indigo = 0x4b0082,\n    //% block=violet\n    Violet = 0x8a2be2,\n    //% block=purple\n    Purple = 0xFF00FF,\n    //% block=white\n    White = 0xFFFFFF,\n    //% block=black\n    Black = 0x000000\n}\n\n/**\n * Different modes for RGB or RGB+W NeoPixel strips\n */\nenum NeoPixelMode {\n    //% block=\"RGB (GRB format)\"\n    RGB = 0,\n    //% block=\"RGB+W\"\n    RGBW = 1,\n    //% block=\"RGB (RGB format)\"\n    RGB_RGB = 2\n}\n\n/**\n * Functions to operate NeoPixel strips.\n */\n//% weight=5 color=#2699BF icon=\"\\uf110\"\nnamespace neopixel {\n    /**\n     * A NeoPixel strip\n     */\n    export class Strip {\n        buf: Buffer;\n        pin: DigitalPin;\n        // TODO: encode as bytes instead of 32bit\n        brightness: number;\n        start: number; // start offset in LED strip\n        _length: number; // number of LEDs\n        _mode: NeoPixelMode;\n        _matrixWidth: number; // number of leds in a matrix - if any\n\n        /**\n         * Shows all LEDs to a given color (range 0-255 for r, g, b). \n         * @param rgb RGB color of the LED\n         */\n        //% blockId=\"neopixel_set_strip_color\" block=\"%strip|show color %rgb=neopixel_colors\" \n        //% weight=85 blockGap=8\n        //% parts=\"neopixel\"\n        showColor(rgb: number) {\n            this.setAllRGB(rgb);\n            this.show();\n        }\n\n        /**\n         * Shows a rainbow pattern on all LEDs. \n         * @param startHue the start hue value for the rainbow, eg: 1\n         * @param endHue the end hue value for the rainbow, eg: 360\n         */\n        //% blockId=\"neopixel_set_strip_rainbow\" block=\"%strip|show rainbow from %startHue|to %endHue\" \n        //% weight=85 blockGap=8\n        //% parts=\"neopixel\"\n        showRainbow(startHue: number = 1, endHue: number = 360) {\n            if (this._length <= 0) return;\n\n            const saturation = 100;\n            const luminance = 50;\n            const steps = this._length;\n            const direction = HueInterpolationDirection.Clockwise;\n\n            //hue\n            const h1 = startHue;\n            const h2 = endHue;\n            const hDistCW = ((h2 + 360) - h1) % 360;\n            const hStepCW = (hDistCW * 100) / steps;\n            const hDistCCW = ((h1 + 360) - h2) % 360;\n            const hStepCCW = -(hDistCCW * 100) / steps\n            let hStep: number;\n            if (direction === HueInterpolationDirection.Clockwise) {\n                hStep = hStepCW;\n            } else if (direction === HueInterpolationDirection.CounterClockwise) {\n                hStep = hStepCCW;\n            } else {\n                hStep = hDistCW < hDistCCW ? hStepCW : hStepCCW;\n            }\n            const h1_100 = h1 * 100; //we multiply by 100 so we keep more accurate results while doing interpolation\n\n            //sat\n            const s1 = saturation;\n            const s2 = saturation;\n            const sDist = s2 - s1;\n            const sStep = sDist / steps;\n            const s1_100 = s1 * 100;\n\n            //lum\n            const l1 = luminance;\n            const l2 = luminance;\n            const lDist = l2 - l1;\n            const lStep = lDist / steps;\n            const l1_100 = l1 * 100\n\n            //interpolate\n            if (steps === 1) {\n                this.setPixelColor(0, hsl(h1 + hStep, s1 + sStep, l1 + lStep))\n            } else {\n                this.setPixelColor(0, hsl(startHue, saturation, luminance));\n                for (let i = 1; i < steps - 1; i++) {\n                    const h = (h1_100 + i * hStep) / 100 + 360;\n                    const s = (s1_100 + i * sStep) / 100;\n                    const l = (l1_100 + i * lStep) / 100;\n                    this.setPixelColor(i, hsl(h, s, l));\n                }\n                this.setPixelColor(steps - 1, hsl(endHue, saturation, luminance));\n            }\n            this.show();\n        }\n\n        /**\n         * Displays a vertical bar graph based on the `value` and `high` value.\n         * If `high` is 0, the chart gets adjusted automatically.\n         * @param value current value to plot\n         * @param high maximum value, eg: 255\n         */\n        //% weight=84\n        //% blockId=neopixel_show_bar_graph block=\"%strip|show bar graph of %value |up to %high\" icon=\"\\uf080\" blockExternalInputs=true\n        //% parts=\"neopixel\"\n        showBarGraph(value: number, high: number): void {\n            if (high <= 0) {\n                this.clear();\n                this.setPixelColor(0, NeoPixelColors.Yellow);\n                this.show();\n                return;\n            }\n\n            value = Math.abs(value);\n            const n = this._length;\n            const n1 = n - 1;\n            let v = (value * n) / high;\n            if (v == 0) {\n                this.setPixelColor(0, 0x666600);\n                for (let i = 1; i < n; ++i)\n                    this.setPixelColor(i, 0);\n            } else {\n                for (let i = 0; i < n; ++i) {\n                    if (i <= v) {\n                        let b = i * 255 / n1;\n                        this.setPixelColor(i, neopixel.rgb(b, 0, 255 - b));\n                    }\n                    else this.setPixelColor(i, 0);\n                }\n            }\n            this.show();\n        }\n\n        /**\n         * Set LED to a given color (range 0-255 for r, g, b). \n         * You need to call ``show`` to make the changes visible.\n         * @param pixeloffset position of the NeoPixel in the strip\n         * @param rgb RGB color of the LED\n         */\n        //% blockId=\"neopixel_set_pixel_color\" block=\"%strip|set pixel color at %pixeloffset|to %rgb=neopixel_colors\" \n        //% blockGap=8\n        //% weight=80\n        //% parts=\"neopixel\" advanced=true\n        setPixelColor(pixeloffset: number, rgb: number): void {\n            this.setPixelRGB(pixeloffset, rgb);\n        }\n\n        /**\n         * Sets the number of pixels in a matrix shaped strip\n         * @param width number of pixels in a row\n         */\n        //% blockId=neopixel_set_matrix_width block=\"%strip|set matrix width %width\"\n        //% blockGap=8\n        //% weight=5\n        //% parts=\"neopixel\" advanced=true\n        setMatrixWidth(width: number) {\n            this._matrixWidth = Math.min(this._length, width);\n        }\n\n        /**\n         * Set LED to a given color (range 0-255 for r, g, b) in a matrix shaped strip \n         * You need to call ``show`` to make the changes visible.\n         * @param x horizontal position\n         * @param y horizontal position\n         * @param rgb RGB color of the LED\n         */\n        //% blockId=\"neopixel_set_matrix_color\" block=\"%string|set matrix color at x %x|y %y|to %rgb=neopixel_colors\" \n        //% weight=4\n        //% parts=\"neopixel\" advanced=true\n        setMatrixColor(x: number, y: number, rgb: number) {\n            if (this._matrixWidth <= 0) return; // not a matrix, ignore\n            const cols = this._length / this._matrixWidth;\n            if (x < 0 || x >= this._matrixWidth || y < 0 || y >= cols) return;\n            let i = x + y * this._matrixWidth;\n            this.setPixelColor(i, rgb);\n        }\n        \n        /**\n         * For NeoPixels with RGB+W LEDs, set the white LED brightness. This only works for RGB+W NeoPixels.\n         * @param pixeloffset position of the LED in the strip\n         * @param white brightness of the white LED\n         */\n        //% blockId=\"neopixel_set_pixel_white\" block=\"%strip|set pixel white LED at %pixeloffset|to %white\" \n        //% blockGap=8\n        //% weight=80\n        //% parts=\"neopixel\" advanced=true\n        setPixelWhiteLED(pixeloffset: number, white: number): void {\n            if (this._mode === NeoPixelMode.RGBW) {\n                this.setPixelW(pixeloffset, white);\n            }\n        }\n\n        /**\n         * Send all the changes to the strip.\n         */\n        //% blockId=\"neopixel_show\" block=\"%strip|show\" blockGap=8\n        //% weight=79\n        //% parts=\"neopixel\"\n        show() {\n            ws2812b.sendBuffer(this.buf, this.pin);\n        }\n\n        /**\n         * Turn off all LEDs.\n         * You need to call ``show`` to make the changes visible.\n         */\n        //% blockId=\"neopixel_clear\" block=\"%strip|clear\"\n        //% weight=76\n        //% parts=\"neopixel\"\n        clear(): void {\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            this.buf.fill(0, this.start * stride, this._length * stride);\n        }\n\n        /**\n         * Gets the number of pixels declared on the strip\n         */\n        //% blockId=\"neopixel_length\" block=\"%strip|length\" blockGap=8\n        //% weight=60 advanced=true\n        length() {\n            return this._length;\n        }\n\n        /**\n         * Set the brightness of the strip. This flag only applies to future operation.\n         * @param brightness a measure of LED brightness in 0-255. eg: 255\n         */\n        //% blockId=\"neopixel_set_brightness\" block=\"%strip|set brightness %brightness\" blockGap=8\n        //% weight=59\n        //% parts=\"neopixel\" advanced=true\n        setBrightness(brightness: number): void {\n            this.brightness = brightness & 0xff;\n        }\n\n        /**\n         * Apply brightness to current colors using a quadratic easing function.\n         **/\n        //% blockId=\"neopixel_each_brightness\" block=\"%strip|ease brightness\" blockGap=8\n        //% weight=58\n        //% parts=\"neopixel\" advanced=true\n        easeBrightness(): void {\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            const br = this.brightness;\n            const buf = this.buf;\n            const end = this.start + this._length;\n            const mid = this._length / 2;\n            for (let i = this.start; i < end; ++i) {\n                const k = i - this.start;\n                const ledoffset = i * stride;\n                const br = k > mid ? 255 * (this._length - 1 - k) * (this._length - 1 - k) / (mid * mid) : 255 * k * k / (mid * mid);\n                serial.writeLine(k + \":\" + br);\n                const r = (buf[ledoffset + 0] * br) >> 8; buf[ledoffset + 0] = r;\n                const g = (buf[ledoffset + 1] * br) >> 8; buf[ledoffset + 1] = g;\n                const b = (buf[ledoffset + 2] * br) >> 8; buf[ledoffset + 2] = b;\n                if (stride == 4) {\n                    const w = (buf[ledoffset + 3] * br) >> 8; buf[ledoffset + 3] = w;\n                }\n            }\n        }\n\n        /** \n         * Create a range of LEDs.\n         * @param start offset in the LED strip to start the range\n         * @param length number of LEDs in the range. eg: 4\n         */\n        //% weight=89\n        //% blockId=\"neopixel_range\" block=\"%strip|range from %start|with %length|leds\"\n        //% parts=\"neopixel\"\n        range(start: number, length: number): Strip {\n            let strip = new Strip();\n            strip.buf = this.buf;\n            strip.pin = this.pin;\n            strip.brightness = this.brightness;\n            strip.start = this.start + Math.clamp(0, this._length - 1, start);\n            strip._length = Math.clamp(0, this._length - (strip.start - this.start), length);\n            strip._matrixWidth = 0;\n            return strip;\n        }\n\n        /**\n         * Shift LEDs forward and clear with zeros.\n         * You need to call ``show`` to make the changes visible.\n         * @param offset number of pixels to shift forward, eg: 1\n         */\n        //% blockId=\"neopixel_shift\" block=\"%strip|shift pixels by %offset\" blockGap=8\n        //% weight=40\n        //% parts=\"neopixel\"\n        shift(offset: number = 1): void {\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            this.buf.shift(-offset * stride, this.start * stride, this._length * stride)\n        }\n\n        /**\n         * Rotate LEDs forward.\n         * You need to call ``show`` to make the changes visible.\n         * @param offset number of pixels to rotate forward, eg: 1\n         */\n        //% blockId=\"neopixel_rotate\" block=\"%strip|rotate pixels by %offset\" blockGap=8\n        //% weight=39\n        //% parts=\"neopixel\"\n        rotate(offset: number = 1): void {\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            this.buf.rotate(-offset * stride, this.start * stride, this._length * stride)\n        }\n\n        /**\n         * Set the pin where the neopixel is connected, defaults to P0.\n         */\n        //% weight=10\n        //% parts=\"neopixel\" advanced=true\n        setPin(pin: DigitalPin): void {\n            this.pin = pin;\n            pins.digitalWritePin(this.pin, 0);\n            // don't yield to avoid races on initialization\n        }\n\n        /**\n         * Estimates the electrical current (mA) consumed by the current light configuration.\n         */\n        //% weight=9 blockId=neopixel_power block=\"%strip|power (mA)\"\n        //% advanced=true\n        power(): number {\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            const end = this.start + this._length;\n            let p = 0;\n            for (let i = this.start; i < end; ++i) {\n                const ledoffset = i * stride;\n                for (let j = 0; j < stride; ++j) {\n                    p += this.buf[i + j];\n                }\n            }\n            return this.length() / 2 /* 0.5mA per neopixel */\n                + (p * 433) / 10000; /* rought approximation */\n        }\n\n        private setBufferRGB(offset: number, red: number, green: number, blue: number): void {\n            if (this._mode === NeoPixelMode.RGB_RGB) {\n                this.buf[offset + 0] = red;\n                this.buf[offset + 1] = green;\n            } else {\n                this.buf[offset + 0] = green;\n                this.buf[offset + 1] = red;\n            }\n            this.buf[offset + 2] = blue;\n        }\n\n        private setAllRGB(rgb: number) {\n            let red = unpackR(rgb);\n            let green = unpackG(rgb);\n            let blue = unpackB(rgb);\n\n            const br = this.brightness;\n            if (br < 255) {\n                red = (red * br) >> 8;\n                green = (green * br) >> 8;\n                blue = (blue * br) >> 8;\n            }\n            const end = this.start + this._length;\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            for (let i = this.start; i < end; ++i) {\n                this.setBufferRGB(i * stride, red, green, blue)\n            }\n        }\n        private setAllW(white: number) {\n            if (this._mode !== NeoPixelMode.RGBW)\n                return;\n\n            let br = this.brightness;\n            if (br < 255) {\n                white = (white * br) >> 8;\n            }\n            let buf = this.buf;\n            let end = this.start + this._length;\n            for (let i = this.start; i < end; ++i) {\n                let ledoffset = i * 4;\n                buf[ledoffset + 3] = white;\n            }\n        }\n        private setPixelRGB(pixeloffset: number, rgb: number): void {\n            if (pixeloffset < 0\n                || pixeloffset >= this._length)\n                return;\n\n            let stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            pixeloffset = (pixeloffset + this.start) * stride;\n\n            let red = unpackR(rgb);\n            let green = unpackG(rgb);\n            let blue = unpackB(rgb);\n\n            let br = this.brightness;\n            if (br < 255) {\n                red = (red * br) >> 8;\n                green = (green * br) >> 8;\n                blue = (blue * br) >> 8;\n            }\n            this.setBufferRGB(pixeloffset, red, green, blue)\n        }\n        private setPixelW(pixeloffset: number, white: number): void {\n            if (this._mode !== NeoPixelMode.RGBW)\n                return;\n\n            if (pixeloffset < 0\n                || pixeloffset >= this._length)\n                return;\n\n            pixeloffset = (pixeloffset + this.start) * 4;\n\n            let br = this.brightness;\n            if (br < 255) {\n                white = (white * br) >> 8;\n            }\n            let buf = this.buf;\n            buf[pixeloffset + 3] = white;\n        }\n    }\n\n    /**\n     * Create a new NeoPixel driver for `numleds` LEDs.\n     * @param pin the pin where the neopixel is connected.\n     * @param numleds number of leds in the strip, eg: 24,30,60,64\n     */\n    //% blockId=\"neopixel_create\" block=\"NeoPixel at pin %pin|with %numleds|leds as %mode\"\n    //% weight=90 blockGap=8\n    //% parts=\"neopixel\"\n    //% trackArgs=0,2\n    export function create(pin: DigitalPin, numleds: number, mode: NeoPixelMode): Strip {\n        let strip = new Strip();\n        let stride = mode === NeoPixelMode.RGBW ? 4 : 3;\n        strip.buf = pins.createBuffer(numleds * stride);\n        strip.start = 0;\n        strip._length = numleds;\n        strip._mode = mode;\n        strip._matrixWidth = 0;\n        strip.setBrightness(255)\n        strip.setPin(pin)\n        return strip;\n    }\n\n    /**\n     * Converts red, green, blue channels into a RGB color\n     * @param red value of the red channel between 0 and 255. eg: 255\n     * @param green value of the green channel between 0 and 255. eg: 255\n     * @param blue value of the blue channel between 0 and 255. eg: 255\n     */\n    //% weight=1\n    //% blockId=\"neopixel_rgb\" block=\"red %red|green %green|blue %blue\"\n    //% advanced=true\n    export function rgb(red: number, green: number, blue: number): number {\n        return packRGB(red, green, blue);\n    }\n\n    /**\n     * Gets the RGB value of a known color\n    */\n    //% weight=2 blockGap=8\n    //% blockId=\"neopixel_colors\" block=\"%color\"\n    //% advanced=true\n    export function colors(color: NeoPixelColors): number {\n        return color;\n    }\n\n    function packRGB(a: number, b: number, c: number): number {\n        return ((a & 0xFF) << 16) | ((b & 0xFF) << 8) | (c & 0xFF);\n    }\n    function unpackR(rgb: number): number {\n        let r = (rgb >> 16) & 0xFF;\n        return r;\n    }\n    function unpackG(rgb: number): number {\n        let g = (rgb >> 8) & 0xFF;\n        return g;\n    }\n    function unpackB(rgb: number): number {\n        let b = (rgb) & 0xFF;\n        return b;\n    }\n\n    /**\n     * Converts a hue saturation luminosity value into a RGB color\n     * @param h hue from 0 to 360\n     * @param s saturation from 0 to 99\n     * @param l luminosity from 0 to 99\n     */\n    //% blockId=neopixelHSL block=\"hue %h|saturation %s|luminosity %l\"\n    export function hsl(h: number, s: number, l: number): number {\n        h = h % 360;\n        s = Math.clamp(0, 99, s);\n        l = Math.clamp(0, 99, l);\n        let c = (((100 - Math.abs(2 * l - 100)) * s) << 8) / 10000; //chroma, [0,255]\n        let h1 = h / 60;//[0,6]\n        let h2 = (h - h1 * 60) * 256 / 60;//[0,255]\n        let temp = Math.abs((((h1 % 2) << 8) + h2) - 256);\n        let x = (c * (256 - (temp))) >> 8;//[0,255], second largest component of this color\n        let r$: number;\n        let g$: number;\n        let b$: number;\n        if (h1 == 0) {\n            r$ = c; g$ = x; b$ = 0;\n        } else if (h1 == 1) {\n            r$ = x; g$ = c; b$ = 0;\n        } else if (h1 == 2) {\n            r$ = 0; g$ = c; b$ = x;\n        } else if (h1 == 3) {\n            r$ = 0; g$ = x; b$ = c;\n        } else if (h1 == 4) {\n            r$ = x; g$ = 0; b$ = c;\n        } else if (h1 == 5) {\n            r$ = c; g$ = 0; b$ = x;\n        }\n        let m = ((l * 2 << 8) / 100 - c) / 2;\n        let r = r$ + m;\n        let g = g$ + m;\n        let b = b$ + m;\n        return packRGB(r, g, b);\n    }\n\n    export enum HueInterpolationDirection {\n        Clockwise,\n        CounterClockwise,\n        Shortest\n    }\n}\n",
  "_locales/ja/neopixel-strings.json": "{\n  \"NeoPixelMode.RGB|block\": \"RGB（GRB順）\",\n  \"NeoPixelMode.RGBW|block\": \"RGB+W\",\n  \"NeoPixelMode.RGB_RGB|block\": \"RGB（RGB順）\",\n  \"NeoPixelColors.Red|block\": \"赤\",\n  \"NeoPixelColors.Orange|block\": \"だいだい\",\n  \"NeoPixelColors.Yellow|block\": \"黄\",\n  \"NeoPixelColors.Green|block\": \"緑\",\n  \"NeoPixelColors.Blue|block\": \"青\",\n  \"NeoPixelColors.Indigo|block\": \"あい\",\n  \"NeoPixelColors.Violet|block\": \"すみれ\",\n  \"NeoPixelColors.Purple|block\": \"紫\",\n  \"NeoPixelColors.White|block\": \"白\",\n  \"neopixel.Strip.showColor|block\": \"%strip|を%rgb=neopixel_colors|色に点灯する\",\n  \"neopixel.Strip.showRainbow|block\": \"%strip|をレインボーパターン（色相%startHue|から%endHue|）に点灯する\",\n  \"neopixel.Strip.showBarGraph|block\": \"%strip|棒グラフで点灯する 値%value|最大値%high\",\n  \"neopixel.Strip.setPixelColor|block\": \"%strip|の%pixeloffset|番目のLEDを%rgb=neopixel_colors|色に設定する\",\n  \"neopixel.Strip.setPixelWhiteLED|block\": \"%strip|の%pixeloffset|番目のLEDの白色を%white|に設定する\",\n  \"neopixel.Strip.show|block\": \"%strip|を設定した色で点灯する\",\n  \"neopixel.Strip.clear|block\": \"%strip|の設定を削除する\",\n  \"neopixel.Strip.length|block\": \"%strip|のLEDの数\",\n  \"neopixel.Strip.setBrightness|block\": \"%strip|の明るさを%brightness|に設定する\",\n  \"neopixel.Strip.easeBrightness|block\": \"%strip|に設定されている色を明るさで調整する\",\n  \"neopixel.Strip.range|block\": \"%strip|の%start|番目から%length|個のNeoPixel\",\n  \"neopixel.Strip.shift|block\": \"%strip|に設定されている色をLED%offset|個分ずらす\",\n  \"neopixel.Strip.rotate|block\": \"%strip|に設定されている色をLED%offset|個分ずらす（ひとまわり）\",\n  \"neopixel.create|block\": \"端子%pin|に接続しているLED|%numleds|個のNeoPixel（モード%mode|）\",\n  \"neopixel.rgb|block\": \"RGB（赤%red|緑%green|青%blue|）\",\n  \"neopixel.colors|block\": \"%color\",\n  \"neopixel.HSL.rotateHue|block\": \"HSL%hsl|の色相を%offset|ずらす\",\n  \"neopixel.HSL.toRGB|block\": \"HSL%hsl|をRGBに変換\",\n  \"neopixel.hsl|block\": \"HSL（色相%hue|彩度%sat|輝度%lum|）\"\n}\n",
  "neotest.ts": "{\n    let strip = neopixel.create(DigitalPin.P0, 24, NeoPixelMode.RGB);\n\n    strip.showColor(NeoPixelColors.Red)\n    basic.pause(2000)\n    strip.showColor(NeoPixelColors.Green)\n    basic.pause(1000)\n    for (let i = 0; i <= strip.length(); i++) {\n        strip.setPixelColor(i, neopixel.colors(NeoPixelColors.Blue))\n        strip.show()\n        basic.pause(100)\n    }\n    for (let i = 0; i <= strip.length(); i++) {\n        strip.setPixelColor(i, neopixel.colors(NeoPixelColors.Green))\n        strip.show()\n        basic.pause(100)\n    }\n    let sub = strip.range(10, 20)\n    sub.showColor(NeoPixelColors.Yellow);\n    basic.pause(200);\n\n    sub.showBarGraph(5, 10);\n    basic.pause(200);\n\n    let br = 100;\n    strip.setBrightness(100);\n    input.onButtonPressed(Button.B, () => {\n        br = br + 20;\n        if (br > 255) {\n            br = 5;\n        }\n        strip.setBrightness(br);\n    });\n\n    let rotationMode = false;\n    input.onButtonPressed(Button.A, () => {\n        rotationMode = !rotationMode;\n        if (rotationMode) {\n            basic.showLeds(`\n            . # # # .\n            # . . . #\n            # . . . #\n            # . . . #\n            . # # # .\n            `);\n        } else {\n            basic.showLeds(`\n            . . # . .\n            . . . # .\n            # # # # #\n            . . . # .\n            . . # . .\n            `);\n\n        }\n    });\n\n    while (true) {\n        let x = input.acceleration(Dimension.X) / 2\n        let y = input.acceleration(Dimension.Y) / 2\n        let z = input.acceleration(Dimension.Z) / 2\n        if (rotationMode) {\n            strip.rotate();\n        } else {\n            strip.setPixelColor(0, neopixel.rgb(x, y, -z));\n            strip.shift(1);\n        }\n        strip.show();\n        basic.pause(100);\n    }\n}\n"
}