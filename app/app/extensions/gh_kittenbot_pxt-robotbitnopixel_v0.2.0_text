{
  "pxt.json": "{\n    \"name\": \"robotbitnopixel\",\n    \"version\": \"0.2.0\",\n    \"description\": \"Extension for Kittenbot Robotbit\",\n    \"license\": \"MIT\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"main.ts\",\n        \"_locales/zh/robotbit-strings.json\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true\n}",
  "README.md": "# robotbit\n\nExtension for Kittenbot Robotbit\n\n## Feature\n\n- Designed for robotic projects over microbit\n- On board battery source\n- Drive 8x servos and 4x DC motors and the same time (with 3.7v battery source to VM)\n- Drive 2x Micro Stepper Motors\n- On board buzzer\n- On board 4x RGB Neo Pixels\n\n# Blocks Preview\n![image](https://user-images.githubusercontent.com/3390845/34512193-b3e0ffdc-f09b-11e7-839f-0c9c3563ac94.png)\n\n# Hardware Preview\n## Front\n![image](https://user-images.githubusercontent.com/3390845/34511999-4b3fdef4-f09a-11e7-960e-5661268b0ba7.png)\n\n## Back\n![image](https://user-images.githubusercontent.com/3390845/34512098-04fecc1a-f09b-11e7-9ec6-62fcc0780773.png)\n\n\n----------\n\nFor more infomation please visit [http://kittenbot.cc/bbs/](http://kittenbot.cc/bbs/ \"Kittenbot BBS\")\n\n## License\n\nMIT\n\n## Supported targets\n\n* for PXT/microbit\n(The metadata above is needed for package search.)\n\n```package\nrobotbit=github:Kittenbot/pxt-robotbit\n```",
  "main.ts": "/*\nR\nmodified from pxt-servo/servodriver.ts\nload dependency\n\"robotbit\": \"file:../pxt-robotbit\"\n*/\n\n\n//% color=\"#31C7D5\" weight=10 icon=\"\\uf1d0\"\nnamespace robotbit {\n    const PCA9685_ADDRESS = 0x40\n    const MODE1 = 0x00\n    const MODE2 = 0x01\n    const SUBADR1 = 0x02\n    const SUBADR2 = 0x03\n    const SUBADR3 = 0x04\n    const PRESCALE = 0xFE\n    const LED0_ON_L = 0x06\n    const LED0_ON_H = 0x07\n    const LED0_OFF_L = 0x08\n    const LED0_OFF_H = 0x09\n    const ALL_LED_ON_L = 0xFA\n    const ALL_LED_ON_H = 0xFB\n    const ALL_LED_OFF_L = 0xFC\n    const ALL_LED_OFF_H = 0xFD\n\n    const STP_CHA_L = 2047\n    const STP_CHA_H = 4095\n\n    const STP_CHB_L = 1\n    const STP_CHB_H = 2047\n\n    const STP_CHC_L = 1023\n    const STP_CHC_H = 3071\n\n    const STP_CHD_L = 3071\n    const STP_CHD_H = 1023\n\n    // HT16K33 commands\n    const HT16K33_ADDRESS = 0x70\n    const HT16K33_BLINK_CMD = 0x80\n    const HT16K33_BLINK_DISPLAYON = 0x01\n    const HT16K33_BLINK_OFF = 0\n    const HT16K33_BLINK_2HZ = 1\n    const HT16K33_BLINK_1HZ = 2\n    const HT16K33_BLINK_HALFHZ = 3\n    const HT16K33_CMD_BRIGHTNESS = 0xE0\n\n    export enum Servos {\n        S1 = 0x01,\n        S2 = 0x02,\n        S3 = 0x03,\n        S4 = 0x04,\n        S5 = 0x05,\n        S6 = 0x06,\n        S7 = 0x07,\n        S8 = 0x08\n    }\n\n    export enum Motors {\n        M1A = 0x1,\n        M1B = 0x2,\n        M2A = 0x3,\n        M2B = 0x4\n    }\n\n    export enum Steppers {\n        M1 = 0x1,\n        M2 = 0x2\n    }\n\n    export enum Turns {\n        //% blockId=\"T1B4\" block=\"1/4\"\n        T1B4 = 90,\n        //% blockId=\"T1B2\" block=\"1/2\"\n        T1B2 = 180,\n        //% blockId=\"T1B0\" block=\"1\"\n        T1B0 = 360,\n        //% blockId=\"T2B0\" block=\"2\"\n        T2B0 = 720,\n        //% blockId=\"T3B0\" block=\"3\"\n        T3B0 = 1080,\n        //% blockId=\"T4B0\" block=\"4\"\n        T4B0 = 1440,\n        //% blockId=\"T5B0\" block=\"5\"\n        T5B0 = 1800\n    }\n\n    let initialized = false\n    let initializedMatrix = false\n    let matBuf = pins.createBuffer(17);\n\n    function i2cwrite(addr: number, reg: number, value: number) {\n        let buf = pins.createBuffer(2)\n        buf[0] = reg\n        buf[1] = value\n        pins.i2cWriteBuffer(addr, buf)\n    }\n\n    function i2ccmd(addr: number, value: number) {\n        let buf = pins.createBuffer(1)\n        buf[0] = value\n        pins.i2cWriteBuffer(addr, buf)\n    }\n\n    function i2cread(addr: number, reg: number) {\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\n        return val;\n    }\n\n    function initPCA9685(): void {\n        i2cwrite(PCA9685_ADDRESS, MODE1, 0x00)\n        setFreq(50);\n        for (let idx = 0; idx < 16; idx++) {\n\t\t\tsetPwm(idx, 0 ,0);\n\t\t}\n        initialized = true\n    }\n\n    function setFreq(freq: number): void {\n        // Constrain the frequency\n        let prescaleval = 25000000;\n        prescaleval /= 4096;\n        prescaleval /= freq;\n        prescaleval -= 1;\n        let prescale = prescaleval; //Math.Floor(prescaleval + 0.5);\n        let oldmode = i2cread(PCA9685_ADDRESS, MODE1);\n        let newmode = (oldmode & 0x7F) | 0x10; // sleep\n        i2cwrite(PCA9685_ADDRESS, MODE1, newmode); // go to sleep\n        i2cwrite(PCA9685_ADDRESS, PRESCALE, prescale); // set the prescaler\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode);\n        control.waitMicros(5000);\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode | 0xa1);\n    }\n\n    function setPwm(channel: number, on: number, off: number): void {\n        if (channel < 0 || channel > 15)\n            return;\n\n        let buf = pins.createBuffer(5);\n        buf[0] = LED0_ON_L + 4 * channel;\n        buf[1] = on & 0xff;\n        buf[2] = (on >> 8) & 0xff;\n        buf[3] = off & 0xff;\n        buf[4] = (off >> 8) & 0xff;\n        pins.i2cWriteBuffer(PCA9685_ADDRESS, buf);\n    }\n\n\n    function setStepper(index: number, dir: boolean): void {\n        if (index == 1) {\n            if (dir) {\n                setPwm(0, STP_CHA_L, STP_CHA_H);\n                setPwm(2, STP_CHB_L, STP_CHB_H);\n                setPwm(1, STP_CHC_L, STP_CHC_H);\n                setPwm(3, STP_CHD_L, STP_CHD_H);\n            } else {\n                setPwm(3, STP_CHA_L, STP_CHA_H);\n                setPwm(1, STP_CHB_L, STP_CHB_H);\n                setPwm(2, STP_CHC_L, STP_CHC_H);\n                setPwm(0, STP_CHD_L, STP_CHD_H);\n            }\n        } else {\n            if (dir) {\n                setPwm(4, STP_CHA_L, STP_CHA_H);\n                setPwm(6, STP_CHB_L, STP_CHB_H);\n                setPwm(5, STP_CHC_L, STP_CHC_H);\n                setPwm(7, STP_CHD_L, STP_CHD_H);\n            } else {\n                setPwm(7, STP_CHA_L, STP_CHA_H);\n                setPwm(5, STP_CHB_L, STP_CHB_H);\n                setPwm(6, STP_CHC_L, STP_CHC_H);\n                setPwm(4, STP_CHD_L, STP_CHD_H);\n            }\n        }\n    }\n\n    function stopMotor(index: number) {\n        setPwm((index - 1) * 2, 0, 0);\n        setPwm((index - 1) * 2 + 1, 0, 0);\n    }\n\n    function matrixInit() {\n        i2ccmd(HT16K33_ADDRESS, 0x21);// turn on oscillator\n        i2ccmd(HT16K33_ADDRESS, HT16K33_BLINK_CMD | HT16K33_BLINK_DISPLAYON | (0 << 1));\n        i2ccmd(HT16K33_ADDRESS, HT16K33_CMD_BRIGHTNESS | 0xF);\n    }\n\n    function matrixShow() {\n        matBuf[0] = 0x00;\n        pins.i2cWriteBuffer(HT16K33_ADDRESS, matBuf);\n    }\n\n\t/**\n\t * Servo Execute\n\t * @param index Servo Channel; eg: S1\n\t * @param degree [0-180] degree of servo; eg: 0, 90, 180\n\t*/\n    //% blockId=robotbit_servo block=\"Servo|%index|degree %degree\"\n    //% weight=100\n    //% blockGap=50\n    //% degree.min=0 degree.max=180\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function Servo(index: Servos, degree: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        // 50hz: 20,000 us\n        let v_us = (degree * 1800 / 180 + 600) // 0.6 ~ 2.4\n        let value = v_us * 4096 / 20000\n        setPwm(index + 7, 0, value)\n    }\n\n    //% blockId=robotbit_stepper_degree block=\"Stepper 28BYJ-48|%index|degree %degree\"\n    //% weight=90\n    export function StepperDegree(index: Steppers, degree: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        setStepper(index, degree > 0);\n        degree = Math.abs(degree);\n        basic.pause(10240 * degree / 360);\n        MotorStopAll()\n    }\n\n\n    //% blockId=robotbit_stepper_turn block=\"Stepper 28BYJ-48|%index|turn %turn\"\n    //% weight=90\n    export function StepperTurn(index: Steppers, turn: Turns): void {\n        let degree = turn;\n        StepperDegree(index, degree);\n    }\n\n    //% blockId=robotbit_stepper_dual block=\"Dual Stepper(Degree) |M1 %degree1| M2 %degree2\"\n    //% weight=89\n    export function StepperDual(degree1: number, degree2: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        setStepper(1, degree1 > 0);\n        setStepper(2, degree2 > 0);\n        degree1 = Math.abs(degree1);\n        degree2 = Math.abs(degree2);\n        basic.pause(10240 * Math.min(degree1, degree2) / 360);\n        if (degree1 > degree2) {\n            stopMotor(3); stopMotor(4);\n            basic.pause(10240 * (degree1 - degree2) / 360);\n        } else {\n            stopMotor(1); stopMotor(2);\n            basic.pause(10240 * (degree2 - degree1) / 360);\n        }\n\n        MotorStopAll()\n    }\n\t\n\t/**\n\t * Stepper Car move forward\n\t * @param distance Distance to move in cm; eg: 10, 20\n\t * @param diameter diameter of wheel in mm; eg: 48\n\t*/\n\t//% blockId=robotbit_stpcar_move block=\"Car Forward|Diameter(cm) %distance|Wheel Diameter(mm) %diameter\"\n    //% weight=88\n    export function StpCarMove(distance: number, diameter: number): void {\n\t\tif (!initialized) {\n            initPCA9685()\n        }\n\t\tlet delay = 10240 * 10 * distance / 3 / diameter; // use 3 instead of pi\n\t\tsetStepper(1, delay > 0);\n        setStepper(2, delay > 0);\n\t\tdelay = Math.abs(delay);\n\t\tbasic.pause(delay);\n        MotorStopAll()\t\n    }\n\t\n\t/**\n\t * Stepper Car turn by degree\n\t * @param turn Degree to turn; eg: 90, 180, 360\n\t * @param diameter diameter of wheel in mm; eg: 48\n\t * @param track track width of car; eg: 125\n\t*/\n\t//% blockId=robotbit_stpcar_turn block=\"Car Turn|Degree %turn|Wheel Diameter(mm) %diameter|Track(mm) %track\"\n    //% weight=87\n\t//% blockGap=50\n    export function StpCarTurn(turn: number, diameter: number, track: number): void {\n\t\tif (!initialized) {\n            initPCA9685()\n        }\n\t\tlet delay = 10240 * turn * track / 360 / diameter;\n\t\tsetStepper(1, delay < 0);\n        setStepper(2, delay > 0);\n\t\tdelay = Math.abs(delay);\n\t\tbasic.pause(delay);\n        MotorStopAll()\n    }\n\n    //% blockId=robotbit_motor_run block=\"Motor|%index|speed %speed\"\n    //% weight=85\n    //% speed.min=-255 speed.max=255\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function MotorRun(index: Motors, speed: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        speed = speed * 16; // map 255 to 4096\n        if (speed >= 4096) {\n            speed = 4095\n        }\n        if (speed <= -4096) {\n            speed = -4095\n        }\n        if (index > 4 || index <= 0)\n            return\n        let pp = (index - 1) * 2\n        let pn = (index - 1) * 2 + 1\n        if (speed >= 0) {\n            setPwm(pp, 0, speed)\n            setPwm(pn, 0, 0)\n        } else {\n            setPwm(pp, 0, 0)\n            setPwm(pn, 0, -speed)\n        }\n    }\n\n\n\t/**\n\t * Execute two motors at the same time\n\t * @param motor1 First Motor; eg: M1A, M1B\n\t * @param speed1 [-255-255] speed of motor; eg: 150, -150\n\t * @param motor2 Second Motor; eg: M2A, M2B\n\t * @param speed2 [-255-255] speed of motor; eg: 150, -150\n\t*/\n    //% blockId=robotbit_motor_dual block=\"Motor|%motor1|speed %speed1|%motor2|speed %speed2\"\n    //% weight=84\n    //% speed1.min=-255 speed1.max=255\n    //% speed2.min=-255 speed2.max=255\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function MotorRunDual(motor1: Motors, speed1: number, motor2: Motors, speed2: number): void {\n        MotorRun(motor1, speed1);\n        MotorRun(motor2, speed2);\n    }\n\n\t/**\n\t * Execute single motors with delay\n\t * @param index Motor Index; eg: M1A, M1B, M2A, M2B\n\t * @param speed [-255-255] speed of motor; eg: 150, -150\n\t * @param delay seconde delay to stop; eg: 1\n\t*/\n    //% blockId=robotbit_motor_rundelay block=\"Motor|%index|speed %speed|delay %delay|s\"\n    //% weight=81\n    //% speed.min=-255 speed.max=255\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function MotorRunDelay(index: Motors, speed: number, delay: number): void {\n        MotorRun(index, speed);\n        basic.pause(delay * 1000);\n        MotorRun(index, 0);\n    }\n\n\n\n    //% blockId=robotbit_stop block=\"Motor Stop|%index|\"\n    //% weight=80\n    export function MotorStop(index: Motors): void {\n        MotorRun(index, 0);\n    }\n\n    //% blockId=robotbit_stop_all block=\"Motor Stop All\"\n    //% weight=79\n    //% blockGap=50\n    export function MotorStopAll(): void {\n        for (let idx = 1; idx <= 4; idx++) {\n            stopMotor(idx);\n        }\n    }\n\n    //% blockId=robotbit_matrix_draw block=\"Matrix Draw|X %x|Y %y\"\n    //% weight=69\n    export function MatrixDraw(x: number, y: number): void {\n        if (!initializedMatrix) {\n            matrixInit();\n            initializedMatrix = true;\n        }\n        let idx = y * 2 + x / 8;\n        matBuf[idx + 1] |= (1 << (x % 8));\n        matrixShow();\n    }\n\n\t/*\n    //% blockId=robotbit_matrix_clean block=\"Matrix Clean|X %x|Y %y\"\n    //% weight=68\n    export function MatrixClean(x: number, y: number): void {\n        if (!initializedMatrix) {\n            matrixInit();\n            initializedMatrix = true;\n        }\n        let idx = y * 2 + x / 8;\n\t\t// todo: bitwise not throw err \n        matBuf[idx + 1] &=~(1 << (x % 8));\n        matrixShow();\n    }\n\t*/\n\n    //% blockId=robotbit_matrix_clear block=\"Matrix Clear\"\n    //% weight=65\n    //% blockGap=50\n    export function MatrixClear(): void {\n        if (!initializedMatrix) {\n            matrixInit();\n            initializedMatrix = true;\n        }\n        for (let i = 0; i < 16; i++) {\n            matBuf[i + 1] = 0;\n        }\n        matrixShow();\n    }\n\n    //% blockId=robotbit_ultrasonic block=\"Ultrasonic|pin %pin\"\n    //% weight=10\n    export function Ultrasonic(pin: DigitalPin): number {\n\n        // send pulse\n        pins.setPull(pin, PinPullMode.PullNone);\n        pins.digitalWritePin(pin, 0);\n        control.waitMicros(2);\n        pins.digitalWritePin(pin, 1);\n        control.waitMicros(10);\n        pins.digitalWritePin(pin, 0);\n\n        // read pulse\n        let d = pins.pulseIn(pin, PulseValue.High, 11600);\n        return d / 58;\n    }\n\n\n}\n",
  "_locales/zh/robotbit-strings.json": "{\n\t\"robotbit.Servo|block\": \"舵机|%index|角度 %degree\",\n\t\"robotbit.StepperDegree|block\": \"步进 28BYJ-48|%index|角度 %degree\",\n\t\"robotbit.StepperTurn|block\": \"步进 28BYJ-48|%index|圈数 %turn\",\n\t\"robotbit.StepperDual|block\": \"双步进(角度) |M1 %degree1| M2 %degree2\",\n\t\"robotbit.StpCarMove|block\": \"步进小车 前进 |距离(cm) %distance|轮直径(mm) %diameter\",\n\t\"robotbit.StpCarTurn|block\": \"步进小车 转向 |角度 %turn|轮直径(mm) %diameter|轮距(mm) %track\",\n\t\"robotbit.MotorRun|block\": \"电机|%index|速度 %speed\",\n\t\"robotbit.MotorRunDual|block\": \"电机|%motor1|速度 %speed1|%motor2|速度 %speed2\",\n\t\"robotbit.MotorRunDelay|block\": \"电机|%index|速度 %speed|延时 %delay|s\",\n\t\"robotbit.MotorStop|block\": \"电机 停止|%index|\",\n\t\"robotbit.MotorStopAll|block\": \"停止所有电机\",\n\t\"robotbit.Ultrasonic|block\": \"超声波|引脚 %pin\",\n\t\"robotbit.MatrixDraw|block\": \"LED矩阵 描点|X %x|Y %y\",\n\t\"robotbit.MatrixClear|block\": \"LED矩阵 清空\"\n}",
  "test.ts": "// tests go here; this will not be compiled when this package is used as a library\n"
}